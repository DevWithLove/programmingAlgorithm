
Adapter
Overview
Welcome to the second module of this course. In this module, we are going to take a look at the Adapter pattern. First of all, we will talk about the motivation for using the Adapter pattern. After discussing what the Adapter is and when you should use it, I am going to show you how to implement it in Swift. We are going to create a fake SocialSharing demo and enhance it with a third party component for posting on Reddit. The Reddit poster class has a different interface than our existing SocialSharing classes. Besides, we cannot modify the implementation of the Reddit poster class. Luckily, the Adapter Pattern comes to the rescue. We are going to see two different ways to integrate the incompatible class with the rest of our code. So why do we need the Adapter Pattern? There are cases when we cannot, or we do not want to, modify an interface, yet we have to use it in our code. The aim of the Adapter is to take the incompatible interface and adapt it to the one we need. One way to implement the Pattern in Swift is to extend the Adaptee to make it compatible with the required interface. Another way is to wrap the object in a dedicated adapter, which will expose the public API we need. I'm going to show you both approaches in a moment. The bottom line is that by using the Adapter, we do not have to refactor our code to use the adaptee's incompatible interface. The Adapter is what actually adapts the incompatible interface to the one we require. Let's say we purchase the third-party library, and we want to integrate it with our existing system. However, the public interface of the new component does not work well with our implementation. Instead of changing our current code, we can introduce an adapter which provides the expected interface. The adapter acts as a middle man. It intercepts requests via an interface that is familiar to the caller and converts these requests to ones that make sense to the adaptee. This brings us to a formal definition of the Adapter pattern. The Adapter pattern converts an existing interface to another interface, which is required to make it compatible with the rest of the software system. This pattern is useful when we need to integrate a component that provides similar functionality to other components in the system, but comes with an incompatible interface.

Object Adapter, Adapter via Swift Extensions
All right, let's implement our SocialSharing demo. First I'm going to highlight the problem which occurs when trying to integrate an incompatible interface using a naive approach. Then, we will discuss how to solve the issue by using the Adapter pattern. I will show you two different Adapter implementations. One that uses object composition, the so-called Object Adapter. Then, I'm going to implement an Adapter which relies on a Swift language feature called extension. Let's switch to Xcode. First we define a sharing protocol which exposes a single method. Message sending and (mumbles) online services. Therefore, the share method is asynchronous. The share method has a message input parameter of type String and a completion handler with an optional error parameter. Given this protocol, we can create various implementation classes. Going to define the FB sharer class first. The share method just brings a message to the console. Note that we do not intend to implement real sharing functionality, but rather demo the benefits of the Adapter pattern. Next, we create a Twitter sharer class. The Share method displays a dedicate console lock two. All right, now we have our implementation classes. However, we do not want clients to interact with these classes directly, but rather take advantage of a fundamental object or in the concept called polymorphism. Polymorphism is the ability of different objects to respond to identical messages, each on its way. In our case, this means that we can invoke the share method on an object without having to know whether it's an FB sharer, Twitter sharer, or any other type which adopts the sharing protocol. Polymorphism allows us to isolate clients from the various types. They only have to know about the protocol. Now, let's create a utility class which provides uniform messaging functionality and exposes only the protocol. The Sharer class provides a share everywhere method which broadcasts a message to all know platforms, that is Facebook and Twitter. The Sharer type and enumeration declares the identifiers. This enumeration can be extended to add identifiers for upcoming types. I also add a custom description which returns the descriptions for the type identifiers. Now that we have all the required pieces, we can complete the implementation of the Share everywhere method. The method iterates through the elements of the shared services dictionary and involves the share method on each of the sharing instances. Every Sharer and the Twitter sharer instance for now. Next, I'm going to expose a share method which allows callers to specify the social platform for sharing the message. Note, however, that we keep the type itself hidden. Instead of exposing the Twitter sharer or FB sharer class, use the sharer type public enumeration to select the desired platform. Then we retrieve the object from the shared services dictionary, and we send the message by calling the share method on that given instance. Now we have a basic framework for sharing messages. How about adding the capability to share messages also on other platforms, for example on Reddit. Instead of implementing the required functionality from scratch, let's assume that we found the third party component for sharing on Reddit. However, the Reddit poster has an incompatible interface. In our desperate attempt to integrate the Reddit framework, we might come up with a solution that does not rely on the Adapter pattern. Let's see where this brute force approach takes us. First, I'm going to enhance the enumeration. Now, I'm going to modify the sharer class so that it uses the new class. I cannot include the Reddit poster in the shared services dictionary since it does not adapt the sharing protocol. Instead I'm relying on polymorphism as we did for the FB sharer and Twitter sharer classes. We had to handle the Reddit poster type separately. I defined the prior Reddit poster instance. By using the lazy keyword, we postpone the creation of the given instance until we first access it. We have to refactor both public methods. First, we modify the share everywhere method. We cannot use the Reddit poster type in the look since it doesn't conform to the sharing protocol. Therefore, we invoke it separately. Let's modify the share method too. I introduce a dedicated check for the Reddit poster type and call its post method. The completion standard of the post method has an addition UID parameter. We skip it since the completion handle of the share method does not have any matching or similar arguments. Initially, our implementation of the sharer class relied on polymorphism; and the code was clean. With the latest changes, our code became messy; and this is just the beginning. The code will continue to grow as we add further incompatible classes. Imagine if we had to add support for sharing on Tumbler, Pinterest, StumbleUpon, and so on by including other third-party frameworks. The sharer class would be filled with conditional logic and additional implementation that is spread through each of its methods. And our example is an overly simplified one. In real life, the added complexity would easily lead to a convoluted code base that is very hard to maintain. Obviously, this is not the right approach. Let's leverage the power of the Adapter pattern. I'm going to create a Reddit poster Adapter, which adopts a sharing protocol to expose the same interface as the Facebook and the Twitter sharer classes. Notice how I use composition to create the so-called Object Adapter. The Reddit poster adapter forwards the request to a Reddit poster instance. When we call the Adapter share method, the request is sent to a lazily initialized Reddit poster instance. Again, I use lazy initialization to postpone the creation of the instance until its very first usage. The Reddit poster Adapter conforms to the sharing protocol, which allows us to include it in the shared services dictionary. Now let's clean up our sharer class by getting rid of all the code we added in our initial attempt to integrate the incompatible Reddit poster class. First comes a share method. I remove the conditional logic, and the Reddit poster specific code. Next, I tied the other share everywhere method. Finally, we can also remove the Reddit poster instance. Our class looks again as lean as it used to be before integrating the third party Reddit poster class. The ability to provide the same functionality with fewer lines of code is a sign of a better, improved design. Now let's try out another approach. There is already easy and elegant way to add the missing methods to the Reddit poster class by using a powerful Swift language feature called extension. Extensions are a convenient way to write an Adapter. Let's define the Reddit poster extension and make it adopt the sharing protocol. We implement the share message method, declaring the sharing protocol. Internally, it will forward the code to the post method of the original Reddit poster class just as we did in Reddit poster Adapter class. The extension-based technique lets us add the missing method to the Reddit poster class without modifying its source code, which was our original goal. Besides, we don't have to introduce a new adapter class. We can now further simplify our code by removing the Reddit poster adapter. After some smaller changes in our sharer class, we are ready to go. While this is already intuitive and straightforward way to implement on Adapter, it only works if there is a common protocol.

Summary
All right, so let's recap what we've learned in this module. The Adapter pattern converts an incompatible interface into one that we need. The Adapter should be used to make things work after they are designed. Choose the adapter if you cannot change the source code of the incompatible type. Don't use an Adapter if you can modify the implementation. Swift extensions let us enhance the type without modifying its implementation. You can also wrap the Adapter object in a dedicated Adapter class which exposes the API we need. The adapter can save us from a lot of refactoring work when integrating incompatible interfaces. A common pitfall is trying to adapt a component which does not provide the required functionality. In the next module, we are going to talk about the bridge pattern. See you soon.

Bridge
Overview
Hi, and welcome to another module in the Swift Design Patterns Structural course. In this module, we are going to take a look at the Bridge pattern. First, we are going to explore the motivation behind using the Bridge pattern. Next, we will implement the messaging demo. I'm going to demonstrate the problem of the sharply increasing number of implementation classes. We'll see how this number decreases after applying the Bridge pattern. The problem of exploding class hierarchies is the motivation behind using the Bridge pattern. You know that you have this problem if the number of your implementation classes keeps increasing whenever you add a new feature. The Bridge pattern solves the exploding class hierarchy problem by separating common and specific functionality into different hierarchies. By decoupling an implementation from an interface, both can vary independently. Here's an example of the exploding class hierarchy. As we add new features, the number of subclasses increases at an alarming rate. There are only two features in this examples and three base classes which implement the common interface. However, the number of implementation subclasses is already six. If I add a third feature, the number of implementation classes will be nine. The solution is to separate the functionality that is unique to the given class from the functionality that is shared between them. If we introduce a separate abstraction hierarchy for the common functionality, we can modify either side independently. Besides, we manage to stop the proliferation of implementation classes. Without the Bridge, we would have nine plus three, that is 12 implementation classes when there are three base classes and three features. After applying the Bridge pattern, the number of required implementation classes is only five. If we had four base classes and four features, the implementation class number increases to 20, 16 implemenation classes plus the four base classes. With the Bridge applied, we only have to deal with eight classes in total. The Bridge pattern separates the abstraction from its implementation and reduces the impact of changes. The Bridge comes to the rescue when the number of subclasses tends to increase sharply with every newly added feature.

The Exploding Class Hierarchies Problem
In this demo, I'm going to show you how a bad design decision can lead to the problem known as exploding class hierarchies. Then, we are going to apply the Bridge pattern to solve this problem. Okay, let's move on and create our demo. I am going to create a message sender demo to illustrate the problem that can be solved with the Bridge pattern. We have our messaging protocol, which declares a method for sending messages. The send method is asynchronous and has an argument of type string code message and a completion handler which can return an error. Now, let's assume that we have to support two messenger services, QuickMessenger and VIPMessenger. I'm going to create the corresponding implementation classes. This is just a demo to showcase the Bridge pattern, so we are not going to implement real message sending feature. The send method just prints off to the console, and it moves the completion block with nil, meaning that there was no error. Later, we need to add the ability to send encrypted messages. To support this new feature, we add the SecureQuickMessenger and SecureVIPMessenger subclasses. The encrypt helper method performs a byte-authorized XOR operation on every character in the method using an encryption key. The exclusive OR operation is a fast and simple way to encode the message and protect it from prying eyes. Here's how it works. The output of the binary XOR is one if the operants are different. If both are equal, then the result is zero. Let's encode the string Hello using XOR and an arbitrary key. First, we retreive the string's UTF8 representation, which includes the string's Unicode scalar values as eight-bit integers. Then, each bit of this eight-bit integers gets combined with the bits of the Key using the XOR operation. If we perform the XOR operation on the encoded result using the same key, we get back the original message. Let's test what we've implemented so far. We can send messages using the QuickMessenger and the VIPMessenger both PlainText and encrypted. Next, we need to support the feature of self-destructing messages. We add two more subclasses, SelfDestructingQuickMessenger and SelfDestructingVIPMessenger. The number of classes keeps increasing as we implement the new requirement. Things get even worse if we must support additional messenger services. Let's what happens if we add a new implementation class called EasyMessenger. We must support secure and self-destructing messages also for this new service, which means two more subclasses. We already have nine classes, and their number will continuously grow as new requirements are coming. In the next clip, we are going to apply the Bridge pattern to solve the problem of exploding class hierarchies.

Applying the Bridge Pattern
Our subclassing strategy leads to a consistently increasing number of implementation classes. We are going to refactor the messaging demo to apply the Bridge pattern and prevent the issue known as exploding class hierarchy. To recap, the Bridge pattern separates the functionality that is specific to a given class from the functionality that is shared between them. The first step is to identify the feature that is common across all implementation classes. If we analyze our classes, we realize that each of them has the capability of sending messages regardless of the message type, so the common part is message sending. What's unique to each class? Obviously, it is the way how messages are prepared and handled. We have plain messages, encrypted messages, and self-destructing ones. We can clearly separate the common message sending functionality from the specific message handling part. Now, we can introduce two abstractions. One, message sending, for the common message sending functionality. Two, message handling, for the message preparation feature that is unique to each class. The message handling protocol declares a method called modify, which is responsible for changing the original message. We need to create three implementation classes, PlainMessageHandler, which leaves the message as it is, SecureMessageHandler, which generates an encoded message, and SelfDestructingMessageHandler, which will create a message tag that's self-destructible. The message sending protocol has a method called Send. Note that we can pass a message handling instance to this method. The message handling instance will modify the message to be sent. Message sending implementation classes are unaware of the message type. We manage to separate the message sending and the message preparation functionality into two abstractions, which was our original goal. By applying the Bridge pattern, we reduce the number of implementation classes from nine to six. From now on, instead of introducing a new subclass for each new feature, we only have to add the new message handling implementation class. Alright, let's refactor our code. We create the message handling protocol first and declare its modify method. Then, we create the message sending protocol. Next, we implement the PlainMessageHandler class. Its modify method simply returns the input string. The SecureMessageHandler uses the encrypt method introduced in the previous clip. Finally, we implement the SelfDestructingMessageHandler class as well. Now, we can write the MessageSending implementation classes. QuickMessageSender, VIPMessageSender, and EZMessageSender. Okay, let's write out our refactored example. We create a QuickMessageSender instance and invoke its send method. Callers must choose the appropriate MessageHandling implementation class and pass the instance to the send method. For example, if we want to send a simple Plain message, then we need the PlainMessageHandler instance. To send an encrypted message, we would instantiate the SecureMessageHandler class. For self-destructing messages, we would need the SelfDestructingMessageHandler. Whenever there is a requirement for a new message type, we only have to add the new message handler. The number and the code of the message sender implementation classes remain unaffected.

Summary
Alright, let's try to summarize what we've learned during this module. The Bridge pattern separates common and specific functionality into different hierarchies. By decoupling the shared and the touch-specific code, both can vary independently. The Bridge pattern solves the exploding class hierarchy problem. When implemented correctly, adding a new feature requires only one additional type. The major pitfall when implementing the Bridge is failing to identify and separate the common parts from the specific features, which is usually not a trivial task. In the next module, we are going to talk about the composite design pattern.

Composite
Overview
Hi, there! In this module, we'll talk about a composite design pattern. As usual, we will start with the motivation for using this pattern. Then, I'm going to demonstrate the problem solved by the composite pattern, by a demo project called DirList. This pattern can be used to create recursive tree structures of related objects where any element can be a composition of objects or an individual object. Each element of the structure may be accessed in a uniform manner without having to know whether we use a collection or a leaf object. All types participating in the composite must implement the same interface. So, here's a formal definition. The composite pattern allows related individual objects and collections of objects to be treated uniformly. Clients can ignore the difference between leaf and composed objects, and only use one type or protocol when accessing the elements within the composite structure.

Creating an Extensible Design with the Composite Pattern
Now, it's time to do some coding. In the DirList demo, we are going to highlight the problem first. Then, we apply the composite design patter, which will not only simplify our initial implementation, but will also make it more robust and easier to extend. In this demo, we implement the utility which maps a directory tree and its files to in-memory objects and brings a structure to the console. First, we are going to create the types that represent files and folders. The file class has an initializer with a name argument of type String. The nesting method allows setting the nesting level of the given file. We are going to use this information to bring the file names in a tree view, which reflects their position in the folder structure. The file class implements a custom string convertible protocol. The custom description returns a formatted string that includes the file name indented according to its nesting level. Since we are not working with a real file system, the file size is randomly generated. Next, we define the directory class. The initializer lets callers provide a name for the directory. The nesting method is similar and has the same purpose as the one we implemented in the file class. A directory can contain files, and also sub-folders. We declare private array quote entries, which can hold both directory, or file-type references. Any object indicates that the type can be any class. The add method allows callers to add new entries. Although the input argument could be an instance of any class, we actually need only entries of type file or directory. We use optional binding to safely check whether the input argument meets our criteria. If the answer is of type file or directory, we adjust its nesting level, then we append it to the entries list. We provide the custom description also for this class. Again, we rely on optional binding to retrieve the answer types. The size method must calculate the size of a given directory by summing up the sizes of all the files and nested directories. We need the conditional logic, also, in this case, to distinguish between entries of type file and directory. Now, we can build a hierarchical directory and file structure. If we print the parent directory, the console will display a nicely formatted tree structure of all the directories and files, including their sizes. The output looks great, but our implementation has some issues. First, the directory class must know about the file class. Then, we need to check the type of each entry whenever we access it. The type-checking code will continue to grow as we add further classes. Here's what we've got so far. We have the file and the directory class. Each directory can contain further directories or files. While this approach works, we just saw that it comes with several issues. We are going to refactor our code by applying the composite pattern. The composite solves the problem by defining a common protocol for individual and composed objects, which lets us treat them consistently. Alright, let's create the file system entry protocol. This protocol defines the methods that need to be implemented by all the leaf and composite objects. In our case, the file class is a leaf, and the directory is a composite, since it can contain further directory objects and file objects, as well. Now, we can refactor the file and directory class. The file class implements the file system entry protocol. We don't need to make any further changes here. Next, we will define the directory class. In this case, we need to make some adjustments. First, we are going to replace the AnyObject type with the File System Entry Protocol. By getting rid of AnyObject, we can specify the types that can be used in the entries array. We have to update the add method, too. Now it only accepts arguments of type FileSystemEntry. And, here's the best part: we can safely remove the type checks, since we know that an entry is always of typedef implement the file system entry protocol. We follow the same pattern to clean up the other methods. The directory class implementation became a lot shorter and simpler. We managed to get rid of all the type checks. Besides, our new design is easy to maintain and extend. Adding a new type will not effect the implementation of the directory class. Running the demo produces the same console output as before applying the composite pattern.

Summary
Let's summarize what we've learned during this module. With the composite pattern, we can represent part, whole hierarchies of objects. We can access the elements without having to know whether we use a collection or a leaf object. Callers can rely on the same type or protocol to access the elements within the composite structure. Common pitfalls: one of the problems you may face when implementing the composite pattern is that your design may become overly general. Leaf and composite objects must implement the same interface so that they can be treated uniformly. Sometimes, this means that we must enforce certain constraints which do not make sense on all types. Defining a common protocol for both the primitive and the composite objects may be challenging when trying to apply the composite pattern on existing software. The composite pattern is best suited to imitable structures. If you need to manipulate the composite structure, our implementation may become overly complicated. In the next module, we are going to talk about another structural pattern, the decorator.

Decorator
Overview
Hello, welcome to the fifth module in this course. In this module, we are going to talk about the Decorator or Design Pattern. First of all, as always, we are going to talk about the motivation for using the Decorator Pattern. Then, we'll explore a Swift language feature called Extensions. Next, I'm going to show you how to implement the Decorator in Swift. We are going to enhance the UIColor class so that it can generate color from HTML color codes. Finally, we create a UI label Decorator which lets us easily creates labels with rounded corners and colored borders. The Decorator or Design Pattern allows adding new behavior to existing types. We can extend the functionality of the type without modifying its implementation which is a flexible alternative to subclassing. The Decorator can be implement via wrapping the object to be enhanced. Another way to extend an existing type is by using the Swift language feature called Extension. Extensions provide the ability to add additional methods to types without having to suppress or change their source code. I'm going to show you how to implement the Decorator via both object wrapping and Swift Extensions. To sum it up, the Decorator or Design Pattern adds new responsibilities to objects without modifying the code of the type used to create them.

Swift Extensions
In the following demo, we are going to explore the possibilities provided by Swift Extensions. Then, we'll implement two flavors of the Decorator pattern. In the first demo, we rely on Swift Extensions to enhance the UIColor class. Finally, we are going to implement on object Decorator by wrapping an instance of the class that we want to extend. All right, so let's take a closer look at Swift Extensions. Extensions provide the ability to extend types for which we do not have access to the original source code. We can add new behavior to existing classes, structures, enumerations or protocols. The concept is similar to Objective-C categories except Swift Extensions do not have names. Let's explore Swift Extensions through some practical examples. Swift Extensions let us add computed instance properties and computed type properties. In this example, we add two new computed type instances to the type Double. This new properties express that the Double value should be considered as a certain temperature unit. The Double value of one represents one degree Celsius. To convert temperatures from Celsius to Fahrenheit, we have to multiply by 1. 8 and add 32. With Swift Extensions, we can define instance methods and type methods. Now we are going to enhance the string type with a method which returns whether the string is lowercase. If we want to provide new initializers to existing types without modifying their source, Swift Extensions are the way to go. Let's add an initializer to the CGVector structure. This new init method allows creating a vector from a CGpoint value. We can add even add subscripts to our Extensions. We going to add an integral subscript to the string type. This subscript returns the character at a given index in the string. For invalid index, if the subscript character returns a skull character. All right, let's iterate to the string and print all the characters. Extensions can also add new nested types to existing classes, enums and structures. These nip adds a nested enumeration called case type to string. The case type enumeration shows whether a string contains all lowercase, only uppercase or mixed case letters. Last but not least, with Swift Extensions, we can make existing types conform to the protocol. Check out the adaptor pedal module for details and examples. Swift Extensions are great to enhance existing types without modifying their source code. To recap, here's what we can do with Extensions, add computed type and instance properties, define instance and type methods, provide new initializers, define subscripts, create and use new nested types, and make existing types conform to a protocol.

Implementing a UIColor Extension and a UILabel Decorator
In this demo, we are going to enhance the UIColor class so that it can create color instances from HTML color codes. We use Swift Extensions to add a new initializer which takes assigned integer as input argument. This argument represents the HTML Color Code. HTML Color Codes are provided as hexadecimal triplets representing the color red, green and blue. The UIColor initializer express float values in the range zero and one. Therefore, we need to extract the bite values from the HTML color code and convert the red, green and blue component from bite values in the range zero, 255 to floating point values. The red component is obtained by performing a bit vice and between the input value and the hexadecimal value FF0000. The zeros in the FF0000 will masked the second and third bites of the input integer. After shifting the results 16 places to the right and dividing it with 255, we get the red component as a float value in the range zero and one. We use a similar logic to calculate the green and the blue values except that the masks are different. For the blue value, we don't need to shift the result since the blue component is represented by the lowest bite. Now we can call the self. init colorLiteral red, green, blue, alpha method with the converted red, green and blue values. So, let's try alter our new UIColor initializer. We create a couple of UIColor instances from HTML color codes. When we run the demo, the colors are generated using the new initializer. We just enhanced the UIColor class through Extensions. Without Extensions, we would need to subclass or rev the UIColor class. However, introducing a new type doesn't provide the same seamless experience as using an ordered existing well-known type. With Extensions, we can even modify the behavior of existing methods. While this is a nice feature, we can replace current functionality by mistake as illustrated in the following snippet. We manage to replace an existing method with one that produces unexpected results. Extensions can be used to add new behavior to existing types without modifying their code. There is one exception though, we cannot add or override stored properties. They have two choices if you must alter the behavior of existing stored properties or add new ones. We can create a subclass or we can decorate the original object. Decorators can modify the behavior of an object that's runtime which is not possible via subclassing. By decorating an object, you won't affect the objects of the same type. The Decorator implement the same interface as the component it is going to decorate. Decorators can modify the existing behavior or add new behavior. The Decorators stores an instance of the wrapped component and forward regress to this object. The original behavior can modified by making changes before or after calling the method of the wrapped component. We are going to implement the UILabel Decorator which allows creating rounded labels with custom borders. The Bordered Label Decorator is a subclass of UILabel and wraps a UILabel instance. The label instance is stored in the wrappedLabel private property. Colors pass the UILabel object in the initializer method along with some other arguments required to decorate the label. Whenever we set a set a property of the Bordered Label Decorator, the value gets assigned to the wrappedLabel instance. Note that we must cause super. init with the valid frame to initialize the super class. Next, we override the properties we are interested in namely text alignment, background color, text color and texts.. For text alignment, background color and text color, we just forward the request to the wrappedLabel instance. However, we modify the behavior of the text property. When a new value is set, we add a funny character at the beginning and at the end of the input string. We must also override the layer property to make sure that we return the layer of the wrapped UILabel instance. Now, we can create UILabel instance and decorate these so that it appears with rounded corners and modified texts.

Summary
All right, so let's talk about what we've learned in this module. The Decorator Design Pattern allows changing the behavior of objects. The functionality of existing types can be extended without subclassing or modifying their source code. Wrapping the object to be enhanced is one way to implement the Decorator. Another option is to use Swift Extensions, a powerful language feature which is similar to Objective-C categories. Note that you cannot add new stored property with Extensions. If you have to add a new property, consider making it a computed property. If this is not option, you'll need to either subclass the original type or use object wrapping. One of the common pitfalls is accidentally replacing the existing functionality of a type which can happen easily with Extensions. Another pitfall is that we may change the original purpose of a type by decorating it with unrelated behavior. In the next module, we are going to take a closer look at the facade design pattern.

Façade
Overview
Welcome to another module in the Swift Design Patterns structural course. In this module, we are going to take a look at the Facade Pattern, a simple yet very useful design pattern. First, we are going to talk about the motivation behind using the Facade Pattern. Then, we implement a Facade component which consolidates the functionality of the URLSession and FileManager classes. The Downloader component exposes a simple, straightforward interface which let's us download latch payloads and stores the result in the file system. The facade is a very simple pattern intended to simplify the use of complicated APIs. It is presented as a single class with a straightforward interface which allows callers to execute common tasks. The Facade may wrap a type with a very complex interface or multiple components which need to be used together. Using the simpler interface is just an option. Callers can still access the wrapped components for lower-level functionality. Complex interface is in fact, the consumer side too. The client code gets complicated and harder to maintain. Interface changes require refactoring on the caller side which can become a serious problem especially when relying on framework or software systems that are still under development or changed frequently. The Facade Pattern consolidates the functionality into a single class and hides the complexity by providing a simpler interface. Clients don't have to use the complicated subsystem directly, instead, they communicate with the Facade. The Facade in turn, involves the APIs of the subsystem it simplifies. So, the Facade not only provides a simpler interface but it also decouples the client implementation from the complex API. If the subsystem interface changes, they only have to adapt the Facade class, not the client code. So here's a formal definition, the Facade pattern simplifies the use of complex APIs by providing a higher-level, simplified interface.

Downloader: URLSession & FileManager Façade
In the following demo, we are going to implement a Swift framework called Downloader which can be used to download large payloads and persist them in the file system. The aim is to create a Facade which consolidates the functionality of URLSession and FileManager and provide a higher level, straightforward API. We are going to create a component which allows the downloading of files to user-defined resource path. The Downloader component aggregates the functionality of URLSession for networking and FileManager for storing the downloaded payload to a local file. The download method is static, so that we can invoke it without creating an instance of the downloader structure. It has URL argument where callers can specify the address of the resource to be downloaded. The localURL argument points to a local file where the resource will be available after a successful download. The method is asynchronous and has a completionHandler which guests called when the download completes. The completionHandler returns two optional arguments. If the call was successful, we return a valid URL response. If something goes wrong, callers can expect the Error instance. We rely on the URL session download test convenience method which can be used to download larger payloads. The download test method takes a URL request argument. We build the URL request instance using the URL of the resource to be downloaded. The download test convenience method has a completionHandler which returns a URL response, an error and a URL which points to a temporary file containing the downloaded content. The temporary file will be removed automatically by the operating system, so we must persist its contents to a permanent location pointed to by the local URL argument. When the completionHandler of the download test method is involved, we expect the return error object. If there was an error, then we call our completionHandler and forward the error instance to the caller. If the download was successful, we must persist the content that is available in the temporary file. First, we check whether there is a temporary file URL available. If there is none, we must signal the error. We are going to dedicate error type. In Swift, we create errors by adapting the error protocol. Let's create a downloader error enumeration which implements the error protocol. We declare the fileCopyError which tells the caller that the temporary payload file could not be copied. To provide the localize error description, we create a downloader error extension and make our error enumeration adapt the localized error protocol. The localized error protocol lets us define localized messages to describe why an error occurred and it also provides additional information. All right, let's go back to our download method implementation. Now that we have our dedicated custom error type, we can test it to the completionHandler. So far, we've been relying on the URLSession, now we need to use the FileManager class too. Next, we check whether there is a file available at the local URL. If there is already a file persisted at the given location then we load the warning and remove the file. If the file cannot be deleted, we call the completionHandler with the dedicated error. We copy the temporary payload file to a location given by the caller. This call may also fail so we have to catch potential exceptions. If the copies succeeds, we just call the completionHandler with the response and the error is new. Threat safety is mandatory when implementing asynchronous methods or functions. We use a serial dispatch queue to protect our download method from concurrent ex's. You can find the detailed discussion about protecting your types against concurrent ex's into single module of the design pattern since fifth creational course. To test our new component, we implement a unit test. Here we go. The beauty of the Facade pattern is obvious if you compare the code we should have written to achieve the same functionality that we get through the simple method code.

Summary
Let's try to summarize what we've learned during this module. The Facade Pattern wraps the types belonging to a complex subsystem and provides a unified higher level interface. Clients can use the type or the subsystem through a simpler API. Another benefit of the Facade Pattern is that it isolates the changes of the underlying type or subsystem from the callers so the client code must not be defactored when the wrapped type change. Use the Facade pattern to simplify the usage of complicated pulling designed interfaces or when adding a convenient layer makes sense. A correctly implemented Facade Pattern lets client use the common features of the wrapped subsystem without directly accessing the underlying types. One of the common pitfalls when implementing the Facade Pattern is leaking the wrapped objects. Changes made to the underlying types will require modifications on the caller side too. See you in the next module where we are going to take a look at the Flyweight Design Pattern.

Flyweight
Overview
Hi there. In this module we'll talk about the flyweight design pattern. After talking about the motivation behind using the flyweight pattern, we are going to demonstrate its usefulness in a practical example. We'll create a logger framework which relies on the unified logging system introduced with iOS 10. We'll apply the flyweight pattern to ensure that only one logger instance gets created for a particular identifier. The motivation behind using the flyweight pattern is to reduce the memory usage and the creation costs for similar objects that rely on the same data. Instead of creating multiple objects, the flyweight pattern shares one instance to represent multiple objects. Each flyweight object is divided into two pieces, the state-dependent extrinsic part, and the state-independent intrinsic part. The intrinsic state is stored in the flyweight object. To implement the flyweight pattern we must identify the immutable state free intrinsic set of properties from the state-dependent extrinsic state. The extrinsic part should be managed by clients and passed to the flyweight instance, whereas the immutable state of the flyweight should be protected from changes. To illustrate the process of identifying the extrinsic and intrinsic state, let's take a classical example. Consider an overly simplified text editor which only lets us use the small letters of the English alphabet. If we are going to write a 200-page document using this editor, we may have approximately 300, 000 characters, assuming 1, 500 characters per page. This means 300, 000 objects where each object has properties like character, size, color and so on. Let's apply the flyweight here. First, we have to identify the intrinsic state, the state or property that can be shared between objects. Every object can have a different color or size. However, the character property can be shared by different objects. So, we create 26 objects which map every unique character of the English alphabet. The character itself represents the intrinsic state of these objects. In the Hello, World example, we used the L character three times, and the O two times. Given the 26 character objects we can create any word or sentence. While callers must not change the character itself they should be able to modify the color or the size of the characters. These properties can vary from object to object. In other words, color and size represent the extrinsic state of the character objects. We can provide some defaults but clients are supposed to set these properties. We managed to identify the extrinsic and intrinsic state of the character object, which saves us a lot of memory and reduces object instantiation overhead. Alright, so here is a formal definition of the flyweight pattern. The flyweight pattern allows the sharing of common objects that can be used identically. It saves memory by reducing the number of object instances at runtime.

FlyweightLogger - A Modern Swift Logging Framework
We are going to implement a logging and framework which lets clients create dedicated loggers. We'll apply the flyweight pattern to ensure that only one logger instance gets created for the particular identifier. Let's first take a look at the UML diagram of our logging framework. The FlyweightLogger protocol declares two computed properties, the subsystem and the category. These properties will uniquely identify a given logger instance. Besides, they also represent the intrinsic state of the logger, that's why we declared them as read only. As we already discussed the flyweight's internal state must not be modified by clients. The subsystem and the category can only be set when initializing the logger instance. The message and log level properties are provided by clients. These properties should not be shared between loggers, they represent the flyweight's extrinsic state. The logger class implements the FlyweightLogger protocol. We'll also need to implement the FlyweightLoggerFactory class, which is responsible for creating and caching the logger instances. To recap, our aim is to create a logging framework which relies on the flyweight pattern. The FlyweightLoggerFactory ensures that only one logger instance can be created for a particular identifier. Alright, let's implement our logging and framework. We declare the FlyWeightLogger protocol first. The subsystem and category properties should be read only as discussed previously. The log method has five arguments, the log message, the log level, the file name, the function or method name, and the line number. The last three arguments identify the source code location where the log was produced. The OSLogType is a structure which defines the log levels and has five values, default, info, debug, add/or, and forward. Note that OSLogType is defined in the OS. log module. Our logger relies on the unified logging system that was introduced in iOS 10. We create a protocol extension to provide default values for the five function and line arguments. Protocol extensions allow us to define behavior on the protocol itself, rather than in each conforming type. We limit the adoption of the FlyweightLogger to class types. We introduce this restriction to avoid the copying of instances. Value types are automatically copied upon assignment, which would defeat the purpose of the flyweight. Next, we implement the logger class. The logger class wraps an OSLog object, which is created using the subsystem and the category values provided you're in initialization. The log method calls the OSLog function. OSLog is part of the new unified logging system API and Apple recommends using it in place of NSlog. We enhance the OSLog type with the custom string convertible extension, which provides humanly readable descriptions for the various log levels. A FlyweightLogger instance might be shared across multiple components and code from different strats in paddler. Therefore, we must protect it from concurrent access. Let's declare a private serial queue. We synchronize the access to our log method using this queue. Last but not least, we implement the FlyweightFactory. We are going to create a single factory. Check out the course design patterns in Swift Creationer to find out more about the singleton design pattern. We want our singleton factory to be accessible only via its shared static property. Therefore, we have the default initializer. Next, we implement the logger method, which returns the FlyweightLogger. This method is responsible for returning exactly one logger instance for a particular subsystem and category pair. The idea behind the FlyweightLoggerFactory is pretty simple. We use an internal cache to store the loggers by their unique identifiers. The identifiers are created by concatenating the subsystem and the category strings. If a logger is found for the given key then we return it. If we haven't persisted a logger for this identifier yet, then a new logger instance is created. The new logger object is added to the internal cache. We'll use a serial queue also in this case to avoid concurrency issues when using the FlyweightLoggerFactory shared instance from different strats. Now, let's run the unit test to check whether the flyweight behaves as expected. Indeed, the same instance is returned for a given key. The flyweight design pattern can be very useful if you need to create several objects which share a common set of properties. It can drastically reduce the memory requirements and the creation costs of objects.

Summary
Let's summarize what we've learned during this module. The flyweight pattern should be used to support a large number of similar objects via sharing. Instead of creating multiple objects, the flyweight pattern shares one instance to represent multiple objects. To implement the flyweight pattern we must separate the immutable set of properties from the state-dependent part. The intrinsic part should be stored in the flyweight object whereas the state-dependent extrinsic part should be managed by clients. The extrinsic state is stored or computed by client objects and passed to the flyweight when its operations are revoked. Common pitfalls. One common issue is that clients can change the immutable state of the flyweight. The intrinsic state of the flyweight objects must not be modified by callers. Another problem is not protecting the flyweight from concurrent access. A shared flyweight instance may be accessed in parallel from several different strats. Therefore, threat safety is imperative. See you in the next module. We are going to talk about the proxy design pattern.

Proxy
Overview
Welcome to the last module in the Swift Design Patterns Structural course. In this module, we are going to take a look at the proxy design pattern. The proxy pattern acts as a surrogate for another object and controls access to it. We'll soon talk more about the motivation behind using the proxy. After that, we are going to implement three variants of the proxy design pattern. We are going to address three different problems. First, we implement an efficient way to access remote objects. Then, we'll work on the solution for loading heavy objects on demand. Finally, we are going to build a proxy for securely accessing sensitive resources. The core idea behind the proxy design pattern is controlling access to objects. We define the placeholder or proxy object which represents another object or a remote service. Clients use this proxy, not the real object. The proxy forwards the client request to the actual subject as necessary. The proxy may also perform optimizations, defer the instantiation of the underlying object, or protect the resource from unauthorized access. We can use proxies in the following situations. Remote proxies allow access to remote resources like RESTful services. The remote proxy acts as a local placeholder for a remote object. Clients can call methods of this local representative, which in turn forwards the request to the remote object. Virtual proxies can be used to manage the creation of expensive resources and the execution of computationally intensive operations. We can improve performance and memory usage by postponing the costly operations until they are actually needed. Protective proxies control access to sensitive objects. The surrogate object checks whether the caller has the appropriate permissions required to use the protected resource. The proxy pattern provides a placeholder for another object to control the way the underlying resource is accessed. The proxy introduces an additional level of interaction to support controlled, remote, or delayed access.

RemoteDataProxy - Remote Proxy in Action
We are going to implement three variants of the proxy design pattern. First, we'll build a proxy for accessing remote data efficiently. Next, we'll create a virtual proxy which minimizes the cost of creating expensive objects. Finally, we'll implement a protective proxy which controls the access to the underlying resource. Now, let's switch to Xcode. The remote proxy minimizes the cost of expensive operations like network calls. The proxy can perform under-the-hood optimizations like doing batch calls or deferring the invocation of expensive operations until performing them is indeed required. In the following example, we are going to implement a remote object proxy. The remote data protocol declares two methods. The data method has an argument where callers can provide the URL of the remote resource. The completion handler returns either a valid data reference or an error. The purpose of the run method is to actually execute the remote call, which is required to fetch the payload from the resource URL. HTTP requests are expensive concerning execution time, bandwidth and energy usage. The remote proxy decouples the execution of the expensive call from actually using the remote data. Besides, we do not expose any details of how the network is used, which isolates callers from future changes in the proxy implementation. The protocol with these two methods is quite straightforward. Note that the data method returns a remote data instance which allows callers to chain the calls to the data and run methods together. This syntax is known as method cascading. Next, we implement the remote data proxy class. The data method doesn't do much in particular. It stores the URL and the completion handler in the corresponding private properties. The real work is done in the run method. We rely on URL session for networking. The task executes asynchronously and the completion block gets invoked when the task completes. We implement some basic error handling. Then, we invoke the callers completion handler that was provided in the data method and stored in the private callback property. The caller components can use our remote proxy by instantiating a remote data proxy object. The client code should include calls to the data method in places where the remote data is used. To recap, there is no network operation involved at this point yet. The client code can trigger a call to the run method when the remote data is indeed needed. This is a way better approach than fetching the data right away since there are may be cases where the remote data is not used at all. By default, the playground won't wait for the asynchronous call to complete. The execution stops right after calling the run method, which returns almost instantly. We need to enable indefinite playground execution which gives enough time for asynchronous call to execute.

ImageProxy - A Virtual Proxy Implementation
The virtual proxy can be used to minimize the cost of creating expensive objects. The remote image protocol declares a couple of properties and an initializer. This is pretty straightforward so let's continue with the implementation class. The image proxy class defines URL and has content properties. Let's take a closer look at the image property. Swift provides an elegant way to implement the virtual proxy pattern. The lazy keyword makes sure that the property is only set if and when it is accessed. Lazy properties must be variables. We can assign a value to a lazy property or we can use a closure if more initialization steps are needed. The image is constructed from a data instance which in turn is initialized with the contents of an URL. This method call may throw an error so we need to handle that. To keep it simple, we use conditional try. If the method throws an error, the error is discarded and the result is nil. If the closure is assigned to a property of a class instance and we refer to the instance or any of its members from within the closure scope, then the closure captures the instance. We end up in creating a strong reference cycle between the closure and the instance. A strong reference cycle causes objects to own each other. Both objects ensure that the other stays alive. Therefore they will never be deallocated. In out case, the image proxy class owns the closure through the image property. And the closure also owns self since we refer to self in the closure. Swift uses capture list to break these strong reference cycles. The unowned keyword prevents the closure from owning the instance, so we don't create a strong reference cycle anymore. Use unowned self only to prevent strong reference cycles when self is known to be around when the closure code gets executed. Next, we add the custom description to our virtual proxy via protocol extension. Protocol extensions allow us to define behavior on the protocol itself rather than in each conforming type. All right, let's try out our virtual proxy. After creating the image proxy object, the image probably should be empty. This fact is confirmed by the log output in the console. We must first access the property for the image to be downloaded and set. And exactly this is the behavior or the aim for with a virtual proxy implementation. Another nice feature that we get for free is that lazy properties get initialized only once. To prove this, we increment a counter in the closure. We then access the image property 10 times from a loop. If the closure were called whenever we access the image property, the console would show a steadily increasing counter value. The image proxy does a great job at deferring the expensive object creation until callers actually need that resource.

SecureImageProxy - Protective Proxy Example
The protective proxy controls access to a sensitive resource. The proxy wraps the protected object and performs certain permission checks before forwarding the request to the real object. So, let's implement a protective proxy which restricts the access to the image proxy we implemented previously. First, we need to define a class which performs the access checks. The authenticating protocol declares the isAuthenticated read-only property and the method to authenticate the given user. The authenticator class implements a very simple way to authenticate users. The authentication is successful only if the provided username matches any of the names defined in the user white list array. This simple check is fine for demo purposes. Clients can use the shared authenticator instance to authenticate users and query the access state. Next, we define the secure image proxy. It implements the remote image protocol, the same protocol as the type it is wrapping, which allows callers to use the protective proxy as a replacement for the wrapped object. Now, let's take a closer look at the implementation of the image property. First, we check whether the user is authorized. If yes, we access the image proxy and query its image property. If the user is not authorized, we return nil. Note that the image proxy is a lazy variable itself. Therefore its instantiation is deferred until we first access it. The secure image proxy restricts the access to the underlying image proxy object. Clients are supposed to use the protective proxy rather than accessing the protective resource directly. To prevent bypassing the secure image proxy, we change the access level of the image proxy class from public to private.

Summary
All right, let's summarize what we've learned during this module. The proxy should be used in the following situations. Allow access to remote resources like RESTful services. The remote proxy acts as a local placeholder for a remote object. Clients can call methods of this local representative which in turn forwards the request to the remote object. Manage the creation of expensive resources and the execution of computationally intensive operations. We can improve performance and memory usage by postponing the creation of expensive resources until they are first accessed. Control access to sensitive objects. The surrogate object checks whether the caller has the appropriate permissions required to use the protected resource. You should not use the proxy pattern if none of these situations apply. Common pitfalls. The proxy object should be used to perform all the required operations on the resource it represents. The benefits of the proxy pattern are rendered useless if clients can bypass the surrogate and use the underlying types directly.
