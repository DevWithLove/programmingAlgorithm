
Getting Started
Introduction
Hi there, and welcome to this course on behavioral design patterns in Swift. My name is Karoly, and I'd like to give you a brief overview about the course. This course covers the behavioral design patterns and the way they are implemented using Swift. Behavioral design patterns describe algorithms and how classes and objects interact with each other and how they distribute responsibility. This one is the third course in the series on design patterns implemented in Swift here on Pluralsight. The first course covers the creation of design patterns and other topics like the history of design patterns and UML basics. The second course discusses the structural design patterns. Some of the patterns we'll cover might sound familiar to you, like the chain-of-responsibility pattern, which stands at the core of the responder chain in iOS and macOS, or the command pattern, which lets us package a method invocation as an object so that it can be invoked later without knowing details of the method. The memento pattern, used to get to the complete state of an object so that it can be returned to an earlier state. We'll also talk about the observer pattern, which allows objects to receive notifications without being tightly coupled to the object which broadcasts those notifications. These are just a few of the patterns that we'll cover. By the end of the course, you will have seen detailed discussions of each behavioral design pattern. For each pattern, I'm going to highlight when to use it. I will rely on UML diagrams to show you how each pattern works. Also, we're going to look at live coding examples to show you how these patterns can be implemented and applied with modern Swift. We're also going to talk about the drawbacks and pitfalls of these patterns. At the end of this course, you will have a good understanding of behavioral design patterns and the way they can be implemented using Swift.

Prerequisites
This is a course aiming at refreshing and deepening your knowledge on behavioral design patterns. Prior programming experience may be helpful, but you need not have actually worked with Swift itself. I'm using Swift 3 and Xcode 8, but it should work with any of the more recent versions of Swift. To implement and build the exercises in this course, you will need a Mac with El Capitan or newer. You will also need Xcode 8 or newer. Xcode can be downloaded for free from the Mac App Store. Download StarUML if you want to inspect the provided UML diagrams or create UML diagrams yourself.

Chain of Responsibility
Overview
Welcome to the second module of this course. In this module, we're going to take a look at the chain-of-responsibility design pattern. First of all, we'll talk about the motivation for using the chain-of responsibility pattern. After discussing what the chain of responsibility is and when you should use it, I'm going to show you how to implement it in Swift. There will be three demos. The first one, called MessageProcessor, shows how to build a sequence of objects and let the right one process a particular message. The BackupService demo is an example of falling back to another service if one fails. Finally, the UI Responder chain demo shows how the responder chain is implemented in iOS. The chain of responsibility is a frequently used pattern. As I show you later, Cocoa and Cocoa Touch relies on this pattern for processing user events, like mouse clicks and taps on the user interface. Now let's talk about the motivation behind using the chain-of-responsibility pattern. The main goal is to decouple the sender of an event or request from potential receivers. The receiving objects form a chain. Basically, they form a linked list so that each object can reference the next one. The request travels through this chain. Each receiving object can decide whether it processes the request. If an object doesn't handle the request, it forwards it to the next handler in the chain. The request travels until one of the responder objects handles it. If none of the objects processes the request, it will reach the end of the chain and nothing happens. Alright, let's see the responder chain in action. The client fires the request, which reaches the first responder object in the chain. This object doesn't handle the request, so it forwards it to the next responder. The second responder doesn't handle the request either. The request travels further through the chain of responders. Now the third responder object decides to handle the request. The request propagation stops here. The next responders are not notified about the request. Sometimes you may need to forward the request even if it was processed by one of the responders. What happens if none of the responders takes ownership of the request? The request keeps traveling through the chain until it reaches the end of the chain. Here's a formal definition. The chain of responsibility organizes potential request processors in a sequence and decouples responders from callers. The request travels until one of the responders processes it or until it reaches the end of the chain. In the next lesson, we're going to implement our first chain of responsibility demo in Swift.

MessageProcessor Demo
In the following demo, we're going to implement several responder types. Each of them will be responsible for processing a particular message. If a responder is not able to handle a message, it is going to forward it to the next responder. Swift encourages protocol-oriented programming, which means that we should start with the protocol, so let's define our protocols. First, I define the Message protocol. To keep it simple for this demo, I declare a single property called name of type String. Next, we'll create the MessageProcessing protocol. I define the initializer first. The init method accepts an argument of type MessageProcessing. This initializer lets responders reference the next responder, which allows us to create the sequence of responders, as we'll see in a minute. The method process will handle a particular message. If the type doesn't deal with the given message, then it must forward it to the next responder. The messageIDs array holds the message identifiers that should be processed by a given processor type. Now that we have the protocols, let's create some types. The ResponseMessage structure adopts the Message protocol. Not too much to discuss here. Next, I'm going to define the XMLProcessor type. Swift prefers well-typed semantics or reference types. Besides, there is no reason to use classes, so we'll just go ahead with structures. The XMLProcessor struct implements the MessageProcessing protocol; therefore, it must implement the messageIDs calculated properly. Remember, this array identifies the messages handled by the given type. XMLProcessor is responsible for XML-type messages. So we simply return a single-element array containing the String XML. Next comes the initializer. It is supposed to set the next responder whom we should forward the request that is not handled by this type. We'll need the property to store the next responder. I'll go ahead and create the nextProcessor property of type MessageProcessing. It is an optional property because it is not mandatory to have a next responder. The sequence of responders must have a final responder. This last responder ends the chain; therefore, it doesn't have a next responder. That's why we need to make the nextResponder property optional so that it can be nil. The initializer only sends the nextProcessor property. Next, we'll implement the process message method. We need to check whether XMLProcessor should handle the message provided as argument. We rely on the whitelist defined through the messageIDs property. We process the message only if it can be found in the whitelist. I use the contains function to find out whether the messageIDs array contains the message name. If found, we'll process the message. For this demo, we'll simply log to the console that will handle the message. If the message is not in the whitelist, we'll forward it to the next processor, if there is any. If there is no next responder, we'll print that we reached the end of the responder chain. We need just one more small addition to improve the readability of our log messages. I add CustomStringConvertible conformance to the XML responder type. This lets us provide a custom description. In this case, it will simply return the name of this type. Now I'm going to implement another type that is responsible for processing JSON messages. The implementation is similar to XML responders code. Only the whitelist and the description are different. Finally, I'm going to implement a dedicated type, which represents the end of the responder chain. We could actually use either of the two types, XML processor or JSON processor, as final node in the responder sequence. We just need to set the next responder to nil when initializing them. However, I believe that it's more intuitive to have a dedicated type to mark the end of the responder chain. The responder chain end structure has a straightforward implementation. It doesn't handle any message; therefore, the messageIDs property is nil. Also, there is no way to set its next processor. The initializer implementation is empty. The process message method logs to the console that you reached the end of the responder sequence. Alright, let's try out our implementation. First, we instantiate the message object. Then we'll build the responder sequence starting with the end element. The ResponderChainEnd instance marks the end of the chain. Next comes the JSONProcessor instance. Upon creation, I set its next responder to responderChainEnd. Currently, we have two responders in the chain. Let's add another responder of XMLProcessor type. This one receives the previously created jsonProcessor instance as its next responder. Our chain of responders starts with an xmlResponder, which has a jsonResponder instance set as nextResponder, and the jsonResponder instance has its nextResponder set the responderChainEnd object. Let's see how it works. I pass the message to the first responder's process method. The message reached the end of the responder chain. Why is that? Well, the message name could be found neither in the XMLProcessor's, nor the JSONProcessor's messageIDs whitelist. Now let's test the positive case too. Both the XML message and the JSON message get processed before reaching the end of the responder chain. Alright, so everything works as expected; however, we could improve our current implementation. The process method is the same in both the XMLProcessor and the JSONProcessor types. Wouldn't it be better to have it defined only once somewhere in a common place? Now both types conform to the MessageProcessing protocol; however, protocols can provide implementation. Luckily, Swift offers a great feature called protocol extension. In the protocol extension, we can provide the float implementations for the methods and computed properties defined in the protocol. So, I'm going to create the MessageProcessing protocol extension. We can simply copy and paste the process message method from, say, the XMLProcessor type. Now we can safely delete the method from both types. You can still override the method in any of the conforming types if the default behavior is not what you want. In this demo, I showed you how to implement the chain of responsibility in Swift. In the next lesson, we'll implement the useful fallback technique, which also relies on this design pattern.

BackupService Demo
Let's assume that we want to create a framework for retrieving weather information. We'll have to relay on the web services to fetch live data from the internet. Web services can be unreliable at times. To maximize our chances, we're going to use multiple services. We'll use a fallback strategy. If a service is unavailable or if it reports an error, we automatically switch to the next service. First, I create the WeatherService protocol. The protocol declares a read-only property called backupService. This property plays a key role in our fallback strategy. The protocol declares an initializer method, which lets us provide the backupService. It is an optional argument, so we can also pass in nil, meaning that there is no backupService. The WeatherService protocol declares the fetchCurrentWeather method for retrieving weather data. The method takes two arguments, the city and the countryCode. The third argument is the completionHandler that will return either the valid weather data or an error. Now we need to define the WeatherData structure. It declares the most important properties describing the weather. The temperature unit is an enumeration which defines three units, imperial, metric, and scientific. Next I assign the appropriate descriptions via type extension, which implements the CustomStringConvertible protocol. Now let's provide the default implementation for the backupService computed property. We'll need to define a WeatherService protocol extension. The default implementation of the backupService just returns nil. We can override this behavior in those classes which are going to fall back to a backupService upon failure. Alright, now let's create some types which implement the WeatherService protocol. Note that we won't use real web services. Our goal is to illustrate the chain-of-responsibility design pattern rather than implementing a full weather application. We'll simulate service failures or data validation issues to demonstrate how the fallback system works. The WeatherServiceError enumeration defines the possible issues, serviceDown, invalid or missing response, and unknown error for everything else. Let's provide localized error messages by implementing the LocalizedError protocol in a type extension. It is always a good idea to provide meaningful error descriptions. OpenWeatherService is the first type which implements the WeatherService protocol. I implement the initializer, which takes an optional WeatherService argument. This sets the backupService property if provided by the caller. We apply the fallback strategy in the fetchCurrentWeather method. If an error occurs, we'll try to retrieve the weather data using the backupService. The hasError helper method returns a serviceDown error. This is just to simulate an error which also may occur in real-world situations. The AccuWeatherService structure is the next type which implements the WeatherService protocol. Everything is the same except that we simulate a noData error in this case. The DarkSkyService is our third type, which conforms to the WeatherService protocol. The hasError method returns no error to mimic a successful weather data fetch from the server. We can finally return meaningful weather information to the caller. Next, we'll build the wrapper which performs the required setup and implements the fallback logic. WeatherServiceWrapper implements the WeatherService protocol, but it actually relies on the three implementation classes to do the real work. The aim of this wrapper is hiding the actual implementation classes and keeping our fallback strategy internal. This lets us make future changes without affecting the callers. The DarkSky adapter instance has no backupService. It is the last service in the sequence. If it fails, we cannot return WeatherData to the caller. I pass in a backupService when creating the AccuWeatherService and the OpenWeatherService instances. The chain of backup services starts with the openWeatherService instance. Its backupService is the accuWeatherService instance. The chain ends with the DarkSky adapter instance, which has no backupService. It is important to invoke the fetchCurrentWeather method on the first object in the chain, which is the openWeatherService instance. So let's test our fallback strategy. I instantiate the wrapper and invoke the fetchCurrentWeather method. The console output tells us what's going on. As expected, the weather data was returned by the DarkSky adapter instance as the two proceeding services failed to handle the request. What happens if we remove the error from the AccuWeatherService? I modify the hasError implementation to return nil. If we run the demo after this change, the actual result is returned by the AccuWeatherService instance. Since this service is not failing anymore, we don't have to fall back to the next service. As we just saw, the chain of responsibility can be used to implement the useful fallback strategy. In the next lesson, we'll take a closer look at event processing in iOS, which is also based on this pattern.

The Cocoa Touch Responder Chain
IOS and macOS apps handle events using responder objects. A responder object can be any instance of the UIResponder class, like for instance, UIView and its subclasses, UIView controller, and UIApplication. UIKit organizes these responders in the chain and manages the event handling automatically. The responder chain on iOS and macOS is based on the chain-of responsibility design pattern. In this demo, we'll analyze how events get delivered from one responder to the next. Also, we're going to modify the default behavior to change how events are delivered within our app. Our application consists of a storyboard file, the AppDelegate, and the ViewController. The AppDelegate inherits from UIResponder, and it's the last responder which receives events. We need to override the touchesBegan UIResponder method in all the classes we're interested in. This lets us drag the event propagation in our app. First, let's override the touchesBegan method in the AppDelegate. Whenever the method is called, a dedicate message appears in the console. Alright, let's run the app. Now if I tap the screen, the message shall appear in the console. This app has only one ViewController. Its main view receives the touch events first. I can prove this by overriding the touchesBegan method of the UIView class. However, instead of creating a UIView subclass, I'll create a UIView extension. Swift type extensions let us decorate an existing type without modifying its source code. In the touchesBegan implementation, I just print the logs so that we can see in the console whether the method was invoked. Let's run the app. Tap, and the result shows that the UIView instance received the event. Note that the AppDelegate's touchesBegan method has not been invoked. Why? Because the UIView object handled the touch event. The event is not forwarded to the next responder in the chain. The UIView touchesBegan method returns without passing the event further in the responder chain. Let's change that by calling the touchesBegan method of the next UIResponder. Note how I use optional chaining to call the method on the next instance which might be nil. This is a convenient way which doesn't require unwrapping the optional value. Alright, let's rerun the app. Now both the UIView and the AppDelegate receive the event. There are further responders in the chain between the first responder main view and the AppDelegate instance. The view passes the event to its ViewController first, which then forwards it to the UIWindow object. Finally, the UIWindow object passes the event to the AppDelegate. I can prove this by overriding the touchesBegan method in the UIViewController and the UIWindow. For the UIWindow, we'll rely on type extensions instead of sub classing, just like we did for the UIView. As usual, I display a log window override and a UIResponder method is called. Also, I make sure that the event is forwarded to the next responder in the chain. Alright, let's run the app. Now we can see how the event gets propagated in the responder chain. Based on our experiment, we saw that the main view received the event first, next comes its ViewController, and then the UIWindow object. The AppDelegate is the final responder. The responder chain changes as we add new sub views or controls. Each subsequent super view in the UI hierarchy can handle the event or pass it to the next responder. By overriding the corresponding UIResponder methods, we can change the default behavior just like we did in this example.

Summary
Here is a brief summary of the chain-of-responsibility design pattern. This pattern organizes request processors in a chain. Responders may or may not process the request. Each responder may handle the request, forward it to the next responder, or forward the request after it processes it. The request gets propagated through the chain until it reaches the last responder in the chain. The chain-of-responsibility design pattern stands at the core of the responder chain in iOS and macOS. It is a widely-used pattern that can solve various problems that require passing the request between objects organized in a sequence. A common pitfall is exposing details of any responder from the chain to other objects in the chain or to the caller.

Command
Overview
Welcome to another module. In this module, we're going to look at the command design pattern. First, we'll talk about the main reasons behind using the command pattern. Then we're going to implement several demo applications. Animation commands, we'll create command objects which encapsulate animation methods and the view we want to animate. Enhanced command, in this demo we'll embed the receiver and the arguments in the command protocol itself. Finally, we'll add support for undo and macro commands. The command pattern encapsulates method invocation in an object. It packages the requests, the receiver, and all the details needed to execute this request into a command object. The command object has usually only one method, execute. We can then use the command object or pass it to other components in the system. Callers trigger the execute method on the command object to invoke the actions on the receiver. The command pattern is useful if you want to decouple components that require specific functionality from the method invocation details and the object which actually executes the actions. The command pattern can be used to implement support for undo operations. Another frequent application of the pattern is creating macros. A macro is a command which executes multiple commands on different receiver objects. Now let's see how the command pattern works using the sequence diagram. First, the client creates the command object. The command object packages the receiver and the set of actions required to execute a given request. Next, the client sets the command on the invoker by calling the invoker's setCommand method. When the invoker needs to perform the given request, it simply invokes the command object's execute method. After that, the invoker may discard the command or it can keep it for further use. Calling the command object's execute method causes the invocation of the actions on the receiver. Here's a formal definition. The command design pattern encapsulates a request into an object. Invokers can call this command object to perform a request without knowing the details required to perform that operation or the receiver that will execute the operation. So this was the theory. In the next demo, we're going to implement our first command demo.

Animation Commands Demo
In this demo, we're going to encapsulate animation method invocations in command objects. We'll create two commands for animating UIViews. We'll start by defining the command protocol. It has a single method called execute. Next, we're going to create some conforming types. First, let's implement the FadeOutCommand structure that is responsible for fading out of view. It conforms to the command protocol, so it must define the execute instance method. The FadeOutCommand will animate an object of type UIView including its sub classes; therefore, I declare a property of type UIView. Internally, we're going to rely on the UIView animate type method, which takes a duration argument. This argument controls the length of the animation. So we need a matching property. Alright, now that we have the properties, we can create an initializer. I set the default duration value to 300 ms. We're almost done, except that we haven't finished the execute method. We want a fadeout effect that will gradually decrease the view's alpha, making it totally transparent. In the animate type method's closure, I set the value of the views alpha to 0. The FadeOutCommand is complete now. Next, we'll create a command for making the view visible again. The FadeInCommand is very similar to the FadeOutCommand. The only difference is that the view's alpha value becomes 1, making the view totally opaque. Now let's implement the client that is going to use the command object. The AnimationController class represents the invoker. It must be totally unaware of how the commands internally work. The AnimationController is decoupled from the UIView the commands operate on and must not know how the animation is achieved. It exposes a method called setCommand, which accepts an argument of type command. This sets the optional command property. The AnimationController's animate method invokes the command object's execute method to run the animation. I use optional binding to call the execute method because the command may be nil. Alright, it's time to test our solution. We'll use playground liveView to display the animated views. For that, we must import the PlaygroundSupport framework. Then we need a containerView, which will be assigned to the PlaygroundPage liveView property. Now we have a canvas we can draw on. We can visualize any view that's added as a sub view to this canvas. Next, we create the view. This is the view we're going to fade out and fade in using our command objects. Let's set its dimensions and center it in the liveView. The background color is white. Next, we instantiate the AnimationController. Then we'll need a command object. First, we'll fade out the view, so we need the FadeOutCommand instance. I slow down the fade out animation by setting the duration to 2 seconds. I introduce a slight delay using the dispatch asyncAfter method. This is just to simulate that we called the animate method at a later point in time. Then, we pass a FadeInCommand object to the invoker and call it after yet another slight delay. Let's run the demo. We're going to use the live preview feature. To open the preview panel, press the Option, Command, Enter keys. Alternatively, we could open it from View menu, then choose Assistant Editor, and then Show Assistant Editor. We should see a white square that slowly fades out, then fades back in. Alright, it works as expected. You might be thinking so much work for such a simple effect. We could achieve the same with the UIView animate method. Yes, that's right. And you should not use the command pattern for regular method invocation, but this is just a demo. Use the command pattern when you want to allow actions to be triggered by callers that have no information about who executes the actions or the arguments needed to perform the action. In the next demo, we're going to create an enhanced version of our command implementation.

Enhanced Command Demo
Currently, the command protocol defines only one method requirement. The conforming types define additional properties and an initializer. Since these properties and the initializer are required for all conforming animation types, we could promote them to protocol requirements. I'm going to create a new protocol called EnhancedAnimationCommand. This is a specialized protocol. It defines the requirements that conforming types must implement in order to animate a UIView instance. Yet, it must also include the requirements defined in the command protocol. Protocols can inherit from one or more protocols. Unlike for class inheritance, we are not limited to inheriting from a single protocol. So, we're going to use protocol inheritance to make our EnhancedAnimationCommand inherit the requirements defined in the command protocol. Next, we'll add the property requirements. The receiver should be UIView. However, we shouldn't enforce a concrete type for the arguments. Currently, we only have a duration argument of type TimeInterval. New types might need other arguments for their animation effects, like color, size, and so on. What we need is a generic argument. Protocols support generic types through associated types. We can declare placeholder types using the associated type keyword. Alright, so let's declare our Arguments associated type. We'll use this placeholder when declaring the Arguments property and the initializer. Types which implement the protocol will provide the exact type. Not every animation type needs an argument, so this property is optional. We can provide the default implementation in the protocol extension. The Arguments calculated property returns nil by default. Now the two properties and the initializer became requirements for each concrete type that implements the EnhancedAnimationCommand protocol. Because the arguments property is optional, we must make some small changes to our FadeOutCommand and FadeInCommand types. Other than that, there are no further changes needed. We use the test code implemented in the previous lesson. If we run the demo, the result must be the same. Indeed, we see the fade out/fade in effect as expected. In this demo, we added a new protocol to define further requirements. These are animation-related requirements, thus we needed a specialized protocol. We use protocol composition to make the EnhancedAnimationCommand protocol inherit the requirements from the command protocol. Types that conform to EnhancedAnimationCommand must implement the requirements from both protocols. We used associated types to define the placeholder type that is unknown at the time of declaring the protocol. In the next demo, we're going to add support for undoing actions. Then we'll implement a macro command, which can execute commands in batches.

Undoable and Macro Commands Demo
A popular application of the command pattern is adding support for undo operations. When the command supports undo, it must have an undo method which reverses what the execute method did. So first, we need to add the undo instance method requirement to our command protocol. Next, we'll implement the undo method in all conforming types. Calling the FadeOutCommand's execute method makes the view transparent. The undo needs to do the opposite. It turns the view from transparent to opaque by increasing the view's alpha to 1. Implementing the undo feature for the FadeInCommand is quite straightforward too. Next, we enhance the AnimationController class. We modify it so that it can perform multiple commands. The setCommand can now accept a command and an identifier. The identifier acts as a unique key. We use it to store the command in a dictionary. Then we replace the animate method with performCommand by id. The id argument is used to retrieve a command from the commandsByID dictionary. If there is no command for the given identifier, we print a warning and return. If we find the Command object, we first append it to the stack of undoable actions. This stack stands at the core of the undo functionality. Finally, we call the command object's execute method. Alright, now let's implement the undo method. First, we must check whether there is anything to reword. If the undo stack contains command objects, we remove the last added one and call its undo method. This will reverse what the last command did. To test the undo feature, we will execute the FadeOut and FadeInCommand. We pass the two Command objects using the new setCommand by id method. Then we perform the FadeOut first, and after a slight delay, the FadeIn too. After 2 seconds, we call the first undo, then the second one. We should see that the view fades out and then fades in. Then, the first undo will reverse the FadeInCommand, producing a fade out animation. The second undo reverses the first animation, which was a fade out, so the very last undo must produce a fade in effect. What we just saw is the result of the FadeOut, FadeIn, undo FadeIn, undo FadeOut sequence. Another frequent application of the command pattern is creating macros of commands. Macro commands let us execute many commands at once. First, we'll create two new animation command types. The ScaleCommand applies an animated transformed to the view. The RotateCommand rotates the view by the angle provided in the argument. The MacroAnimationCommands class has two methods. AddCommands lets callers pass an array of commands that we want to execute at once. The commands get stored in the internal commands array. The execute method iterates over the command objects contained in the commands array. We invoke the execute method on each command object. For testing, we'll first create a macro commands instance. Then we instantiate the scaleUp, fadeOut, and a rotateCommand object. We'll then pass the array containing the three commands to the MacroAnimationCommands instance. Let's see what happens if we call the macro. execute method. The scaleUp, fadeOut, and rotate perform all at once. This was our last command demo. In the next video, I'll summarize what we've learned in this module.

Summary
Let's summarize what we've learned about the command design pattern. The command encapsulates method invocation, including all the details needed to perform the action. Callers can trigger the action at a later time without knowing the receiver or the actions that get executed behind the scenes. With this pattern, we decoupled the object that makes the request from the object that actually receives and executes the request. The command pattern is easy to implement. The most common pitfall is exposing details of the receiver object or any information needed to perform the action to the component that is using the command object. You should also protect your command objects from concurrent access, as they may be used by multiple components and from different threads. In the next module, we'll explore the interpreter design pattern.

Interpreter
Overview
Hi. In this module, we're going to look at the interpreter design pattern. First, we'll talk about the reasons for choosing this pattern. Then we're going to implement two demos to show the interpreter pattern in action. In our steering demo, we'll define the basic navigation language. The second demo is about implementing a calculator which uses more complex expressions. Now let's talk about the concepts surrounding the interpreter pattern. The interpreter is a behavioral pattern. It is used to represent the language, define its rules along with an interpreter to interpret these rules. Use the interpreter when a set of problems occurs frequently. We should map the domain to a language with a small set of rules. In other words, the grammar must be simple. If we can't express the domain with a relatively small set of rules, the interpreter pattern might not be a good fit to solve that particular problem. We map each sentence in the grammar to a specific type, and each type contributes to the process of interpreting the sentences. Now let's take a look at the design of the interpreter pattern. The expression protocol defines a single method requirement, interpret, which takes a context argument. The context represents a global state that is used as input and output by each expression type. We can have two kinds of expressions. The TerminalExpression represents an expression that does not contain other expressions, whereas the NonterminalExpression maps a compound symbol in the grammar. A compound expression either relies on multiple terminal expressions, or it calls itself recursively until it reaches a TerminalExpression. The client parses the sentences, builds the list of Terminal and NonTerminalExpressions, and invokes their interpret method sequentially. Here is a formal definition. The interpreter design pattern defines a language with a simple grammar. It provides an object representation of each grammar rule, along with an interpreter to interpret the grammar. Now let's look at an example which shows the steps of the mapping process. Here are some simple navigation instructions. First, we'll try to identify the key expressions and build a simple language. Head North describes the change in direction, so we map it to a corresponding expression. Go represents movement. Let's map it to the move expression. So far, we have an expression for changing the direction and one for moving forward. Go 1 mile. To keep it simple, we'll assume that 1 move command means moving forward for 1 mile. Simplification typically comes with some tradeoffs and limitations. We could build a compound expression which includes two terminal expressions, one for moving, and another one which represents the distance, but let's rather keep our grammar simple. Turn left indicates a change in direction. Since we were heading North, turning left means heading West. So we can define a new terminal expression, headWest. Proceed also means movement, so we can map it to the move expression. Since 1 move expression represents moving forward for 1 mile, moving 3 miles can be described using 3 move expressions. Take a right, a change in direction. We were heading West, so turning right means that we'll be heading North. We already have an expression for this. Go maps to the already defined move expression. We have to drive for 2 miles, which in our simple grammar translates to 2 move expressions. Here are the original text and its mapping to the newly defined grammar. Our grammar has very few expressions, yet it navigates us accurately. Next, we create a concrete type for each expression. In Swift, move and North could be implemented as a class or as a value type. We get the basic navigational language by defining further expressions. In the following videos, we're going to see some examples of the interpreter design pattern put into action.

Steering Demo
In this demo, we're going to create a basic steering command interpreter. In the previous video, we mapped humanly-readable navigation instructions to a language with a small set of expressions. Now that we have the language and the simple grammar, let's implement a working solution in Swift. We start with the expression protocol, which defines a single method requirement. The interpret method takes a context argument. We're about to build a steering demo, so the context should express the position and the orientation of an object. In computer vision and robotics, the combination of position and orientation is referred to as pose, so let's create a structure called Pose. The position and the orientation properties are tuples of type Int. Now we can complete the interpret method. The context is an inout parameter. Its value can be modified by the method we pass it in. The new value replaces the original value supplied by the caller. This behavior is exactly what we need for the global interpreter context. To recap, the context represents a global state used as input and output by each expression type. Next, we need to map the rules of our simple grammar to Swift types. As you may remember, we only have five expressions, so we'll need to create five Swift types in total. But first, we need to talk about directions and coordinates. This demo is an iOS Xcode playground project. The default coordinate system for views in iOS has its origin at the upper left of drawing area. Positive values extend down and to the right from it. We'll use the standard North-up map orientation. Given the coordinate system, we can define our directional vectors as follows, which in turn maps to the following tuples. Now we can create the types that represent the four headings. First, let's implement the North type. North confirms to the expression protocol. In the interpret method, we update the orientation property. It must reflect that the object should head North. Then we implement the other three direction types in a similar way. South points downward, East points to the right, and West points to the left. The move type needs to change the position considering the current heading. A change in position of only one point at a time would be hardly noticeable, so let's scale up the displacement by multiplying it by 10. Next, we create a special expression. The unknown struct represents invalid expressions encountered by parsing the grammar. Now comes the client part. Here's a sentence which describes a sequence of direction commands. After splitting the string, we get an array of expression strings. I'm going to initialize the context with the starting Pose. Next, we iterate through the expression list. We create a terminal expression instance for each expression and pass the context to their interpret method. The context is an inout parameter. The result of each call is accumulated and passed into the next interpret call. After iterating through the expression list, the context will contain the final position. Notice that we store each position in the positions array. We're going to use these coordinates to draw a path. By drawing this path, we can visualize the context changes made by each expression. We need to cast a UIView class to build and display the path. The PathView class overrides the UIView's draw method. Here is where we build a Bezier path using the stored coordinates. Now we can instantiate a PathView instance. To display the path, we must assign the view to the current PlaygroundPage liveView. To reveal the liveView, press Command+Option+Enter, or select the View menu and choose Assistant Editor, Show Assistant Editor. Here is the result of evaluating the steering expressions. We can modify the output by updating the string containing the steering commands. Note that there were no code changes required. We could also extract the string to an external text file. This would enable us to modify the navigation commands and interpret them without recompiling the app. The outcome would be a simple scripting engine. In the next video, we're going to build a calculator, which uses compound or non-terminal expressions.

Calculator Demo
Now let's look at another example of implementing the interpreter design pattern. In the previous demo, we used terminal expressions to represent each navigation command. Now we're going to create a calculator which uses non-terminal expressions. To recap, expressions that contain other expressions are called non-terminal expressions. In this demo, we implement a solution for evaluating sentences like this. The key expressions are: number, addition, and subtraction. We identified the rules. So, let's start implementing the solution. We start with the Expression protocol. The interpret method has no parameters, and it just returns a Double. Now that we have the protocol, we can create the number type. The initializer lets callers provide the value that is returned by the interpret method. Next, we need to define the types for addition and subtraction; both require two operands. The Expression protocol doesn't specify these properties, so we'll create another protocol that adds the missing requirements. CompoundExpression inherits from the Expression protocol, and it adds two property and an initializer requirement. Alright, now we can create the Add type. It is a struct and conforms to CompoundExpression. CompoundExpression inherits from the Expression protocol; thus, conforming types must implement the requirements defined in both protocols, leftOperand, rightOperand, the initializer, and the interpret method. Its interpret method calls the interpret method of each operand. Then it sends the return values and returns the result. We implement the Subtract type in a similar way. Next, we'll build a function to tokenize and parse the input string. Parse takes a String parameter and returns the result of the evaluation as a Double. It works by tokenizing the input String and iterating through the list of expressions. A valid expression can be a number, plus or minus. If the parser finds the plus token, it checks for the existence of the required left and right operands. The accumulator stores the value of previous evaluations. We use the accumulator as the left operand for the add operation. The right operand is the next token in the expression list. If there is none, or if it's not convertible to a Double, we report an error and stop the processing. There must always be a right operand for the Add and Subtract operation. If we find the right operand, we create the Add expression and call its interpret method. This triggers the invocation of the interpret method on both operands and sums the results. The accumulator gets updated, and we bump the index. The index must point beyond the next item since we already used it for our right operand. Subtraction works the same way. We check for the right operand. If found, we create the Subtract instance and call its interpret method. If the token is neither plus nor minus, we assume that it's a number. If the conversion to Double fails, we log a warning and proceed with the next token. Also, we can't have two or more successive numbers in the input, so we perform some syntax validation. If there is a previous token, it must represent an operation; otherwise, we log an error and return an invalid value represented by not a number. If all goes well, the value gets wrapped in a Number instance and is sent to the accumulator. We keep iterating through the list of tokens. For each valid token, we create a terminal or a compound expression. Their interpret method gets called, and we update the result. Alright, let's start the demo. It works as expected. We can also test our validation logic using an invalid input. The interpreter is a powerful pattern. We saw two simple applications, but the possibilities are endless. Yet, we must also watch out for potential issues. We'll talk about the pitfalls of the interpreter in the upcoming summary.

Summary
So, let's summarize what we've learned in this module. The interpreter is a special kind of pattern. Use this pattern to map a domain to a simple language with a grammar consisting of a small set of rules. Each rule has a matching type, and each type contributes to the process of interpreting the language. Use the interpreter when the domain is well defined, and it can be described using a simple grammar. A common pitfall of the interpreter is that it can become complicated. The number of required types increases as the language becomes more verbose. This complexity can lead to maintenance and performance issues. Besides, the interpreter does not address parsing; thus, other approaches, like for example a parser generator, may be a better choice. The next pattern we're going to look at is the iterator. It is one of the most popular patterns, and we use it even without thinking about it.

Iterator
Overview
Hi. This is Karoly Nyisztor. In this module, I'm going to talk about the iterator design pattern. The iterator pattern provides a way to navigate through the elements of a container. It does so without exposing the structure of the object it traverses. Soon, we'll talk about the design and the underlying concepts behind the iterator. Then we're going to implement a custom stack. We'll add the ability to iterate Swift's elements using the for-in loop. In the second demo, I'll show you how to create a custom iterator from scratch. Now let's talk about the importance of having a pattern for traversing containers of objects. There are different structures that let us store data in a structured format. Swift provides built-in collection types, and we can create our custom aggregates, like stacks, linked lists, trees, and so on. These data structures should provide a way to step through their elements. We could come up with different solutions to access their elements sequentially. As a result, the interface of these data structures will be cluttered with operations for different traversers, and these operations would vary from type to type, which in turn makes them hard to use and maintain. The iterator pattern addresses this problem. It provides a standard interface for traversing different types of aggregate objects. The iterator encapsulates the access and traversal logic in a separate type; thus, it removes these responsibilities from the data structure. So we don't have to expose any of the details of the underlying data structure to iterate to its elements. Alright, so this is the official definition of the pattern. The iterator provides sequential access to the elements of a container without exposing its underlying details. It removes the operations for different traversers from the data structure itself. Now, let's take a look at the design of the iterator pattern. The Swift standard library has two protocols that let us implement custom iterators. That is, it provides sequential access to their elements should adopt the Sequence protocol. All built-in collection types, the array, the set, and the dictionary, conform to this protocol. Our custom types must also adopt the Sequence protocol if we need to iterate through their elements. Sequence defines a couple of method requirements. The one that is relevant to us is the makeIterator method. This method creates an iterator that provides access to the elements of the sequence. The IteratorProtocol provides a unified interface for accessing the items in the sequence one at a time. The next method advances to the next element in the sequence and returns it. Actually, we're using the given type's iterator whenever we rely on the for-in loop to iterate through its items. Here's a straightforward example of iterating through the elements of an array. And here's what's happening behind the scenes. The compiler generates the following code. It first creates an iterator by calling the array's makeIterator method. Then, the while loop calls the iterator. next. The loop exits when the next method returns nil. Knowing these details is important when implementing custom iterators. Our next method implementation must also return nil to signal the end of the sequence; otherwise, the loop will continue forever. Alright, enough theory. In the next video, we'll implement the custom stack. We're going to add support for iterating Swift's elements using a for-in loop.

Stack Traversal Demo
In this demo, we're going to implement a custom data structure and provide iterated access to its elements. Let's start by defining a stack. It's a generic type, just like the built-in collection types. The Stack stores its elements in order like the array. However, we can't randomly insert elements into a stack. The Stack only allows appending a new item to the end of the collection. This operation is referred to as push. We use a private array to store the elements. The push method simply adds the new elements to the internal storage. In a Stack, we can only remove the last item. This operation is known as pop. This is how our pop method shall behave. It removes the last element from the private storage by calling the array's popLast instance method. Let's test our Stack. We add new items using the push method. The item that was added last can be removed first. Although we can't randomly access the Stack's contents, it would be useful to iterate through its elements. Currently, this code won't compile. The error message is quite clear. Our type must conform to the sequence protocol. To recap, the sequence protocol lets us define types that provides sequential access to their elements. Sequences must implement the makeIterator instance method. This method returns an iterator, which in turn provides access to their items. We're going to adopt the sequence protocol in an extension. Type extensions are an elegant way to organize the code into smaller, logical blocks. So the makeIterator must return an iterator. Luckily, we don't have to reinvent the wheel. Our Stack uses a private array for storing the elements, and the array conforms to the sequence protocol, just like the other primary Swift collection types. In other words, the array implements the makeIterator method. Indeed, we can return the private array's iterator. This iterator provides sequential access to the elements of the internal array, and this is exactly what we need. Now we can use our stack instances in a for-in loop. The code builds without issues, and the log shows that the loop traversed the entire stack. Swift makes it easy to implement the iterator pattern. Besides, conforming to the sequence protocol will enable other useful features too. So far so good. But unlike in this example, we may not always get the iterator for free. In the next demo, I show you how to implement a custom iterator.

Custom Iterator Demo
In the previous demo, we relied on the array's iterator in our custom stack type. Now we're going to implement the makeIterator method from scratch. Let's delete the implementation of the makeIterator method. Instead of returning a valid iterator, we stop the execution of the demo through the fatalError function. This will remind us to add the missing implementation. As you may remember, Swift provides two protocols for implementing the iterator design pattern. The Sequence protocol lets us define types with sequential access to their elements, and we can use the IteratorProtocol to create custom iterators. As discussed in the documentation, the IteratorProtocol is tightly linked with the Sequence protocol. Sequences provide access to their elements by creating an iterator, which keeps track of its iteration process and returns one element at a time as it advances through the sequence. Let's take a closer look at the Sequence protocol. The makeIterator shall return a custom iterator. The iterator is an associatedtype. The exact type must be provided by the conforming types. The associatedtype has a type constraint. This constraint specifies that the iterator type must conform to the IteratorProtocol. Now if we inspect the IteratorProtocol, we'll find that it's surprisingly simple. It only defines one method requirement, the next method. Conforming types must implement this method so that it advances one step in the sequence and it returns the current element. If there are no more elements, the next method returns nil. Alright, so let's start implementing the custom iterator. We'll call it simply StackIterator. It must be generic since the Stack is also generic. The next method returns this placeholder type. The method must access the Stack's contents to track the index and return the current element. So, we have to pass the elements to the iterator. We can do that in the makeIterator method where we initialize the StackIterator. Now that we can access the Stack's elements from the iterator, let's continue with the next method. First, we need a property to store the current index. Upon entering the next method, we first check whether the Stack has further elements. If the current index has reached the size of the internal storage, we return nil. A nil return value signals that the Stack is exhausted. Otherwise, the method returns the element at the current index. Then we increment the value of the current index property. So we created a custom iterator for our Stack type. We can simplify the implementation by making our stack conform to the IteratorProtocol and the Sequence protocols. First, let's move the next method to the Stack extension. Extensions can't have stored properties. Thus, we add the current index property to the Stack structure. By removing the makeIterator method, the default implementation applies. The default implementation returns the stack object itself because the Stack adopts the IteratorProtocol. Finally, we can delete the StackIterator. Our code should compile without problems. Now let's run the demo. The output is the same as before. The only difference is that now we've got fewer lines of code.

Summary
To recap, the iterator provides sequential access to the elements of an aggregate object. It encapsulates the operations for different traversals into a dedicated iterator type. The iterator, if implemented correctly, does not expose the internal structure of the traversed object. As we saw, Swift make it very easy for us to implement the iterator design pattern. We can create types with sequential access by adopting two protocols. Types that provide iterated access to their elements must adopt the sequence protocol. Custom iterator types have to conform to the IteratorProtocol protocol. The iterator must keep track of the traversed elements. Calling its next method returns the current element, and it advances one step in the sequence. The iterator pattern is one of the most frequently used ones. There are no pitfalls, but you should always consider the performance impact of your iterator implementation. The next method must not perform slow or computationally-intensive operations. Next, we'll talk about the mediator design pattern.

Mediator
Overview
In this module, we're going to talk about another popular design pattern called the mediator. Let's talk first about why and when should we use this pattern. Then we'll implement a SmartHome demo. I'll show you how to refactor a tightly coupled system using the mediator pattern. Alright, let's take a look at the motivation behind using this design pattern. The mediator design pattern simplifies the communication between objects. It does so by introducing the middleman. In other words, the mediator. Each object communicates only with the mediator. The letter contains all the logic that defines how the objects interact. The mediator pattern promotes loose coupling. The objects must not refer to each other directly. By removing the dependencies between the peers, we get a better, more flexible design. Since the objects are not connected, they can function independently. We can easily reuse or modify them as they are not tightly coupled with other types, whereas if the number of connections between objects is high, we get the monolithic system. Such systems are hard to maintain. To illustrate what the pattern does, let's look at a smart home example. Our smart home kit has several sensors and appliances. The sensors can capture a wide variety of events. Each sensor collects some particular environmental data. The air quality detector measures levels of carbon monoxide in the air. It fires the alarm if the levels are dangerous. The motion sensors can alert us if there's movement within our home. They are also great for helping to save energy. These sensors can be connected to lighting and control the energy usage based on the occupancy of the room. A smart thermostat monitors the temperature inside the house. Combined with the motion sensor, smart thermostats can adjust the temperature on a room-by-room basis. They allow you to maintain the ideal ambient temperature while you're in the room. When no one is in the room, the smart thermostat will switch the heating or cooling to energy saving mode. Now this works fine. Yet, as we add new sensors and appliances, the number of connections increases, and with this it gets hard to keep track of how the various sensors and devices communicate with each other. Eventually, the wiring becomes overly complex. This makes it difficult to make any changes or fix potential issues. Here's where an intermediary can help us. Instead of linking every connected device one by one, we introduce a hub. The sensors and the appliances communicate with this mediator, and they are now totally decoupled. The sensors notify the mediator when their state changes, and the appliances respond to requests from the mediator. The mediator encapsulates the logic for our smart home system. If we need to add a new sensor or appliance, like for example an illumination sensor or a smart door, the necessary logic will be added to the mediator. The mediator removed the tightly coupling between the objects that need to communicate. So this was a practical example which demonstrates the benefits of the mediator pattern. And here's a formal definition. The mediator encapsulates how objects interact and promotes loose coupling by keeping objects from referring to each other explicitly. Next, I show you a coding example of how to decouple objects in a software system.

SmartHome v1.0
In the following demo, we'll start with the system where the objects are tightly coupled. Then we'll refactor it to remove all these dependencies by applying the mediator pattern. To save us some time, I've gone ahead and implemented the SmartHome demo as an Xcode playground project. You can download this project, along with all the other exercise files with this course if you wish to follow along with me. In this demo, we'll simulate the smart home configuration, which has three sensors and a couple of home appliances. We have a carbon monoxide detector, a motion sensor, and a thermostat. We've also got an alarm and equipment for lighting, heating, and cooling. We represent each sensor and appliance using classes. Why aren't we using value types, you may ask. Well, we try to represent real, external objects. Copying such objects like a thermostat or a light bulb doesn't make sense; thus, we don't want the automatic copy behavior that comes with value types. To represent an external entity, a reference type is usually the right choice. First, we've got a carbon monoxide detector class. It has a private property of type Alarm and an initializer that takes an alarm instance as argument. The carbon monoxide detector trips the alarm in the onCOHigh method. Calling the onCONormal simulates that the carbon monoxide levels are back to normal. Now let's take a look at the Alarm class. It has two properties, isOn of type Bool, which tells us whether the alarm is currently active or not. I introduced the ArmingModes enum for the ArmingMode property. The enum has two cases, stay, which is used when you are at home, and away, used when you leave the house and arms your security system so that it protects your entire home. The default value is stay. The trigger method will trip the alarm if it's not already active. For this demo, we'll just set the isOn property to true and print to console log which says Alarm activated, along with the reason for activating the alarm. The disable method stops the alarm if it's been activated. It sets the isOn property to false and prints the message Alarm stopped to the console. The next sensor is the MotionSensor. The MotionSensor is connected with the alarm, the lighting, and the thermostat. By connecting the thermostat and the motion sensor, we can make our home even smarter. The thermostat can switch the heating or cooling to energy saving mode if there is nobody at home. This feature is optional. That's why the Thermostat property is optional too. The initializer lets callers supply the alarm, lighting, and optionally the thermostat instances. The Thermostat argument has a default nil value, so we can call the initializer with only two parameters. The onMotionStateChanged method has a state parameter. True means that motion occurred in the sensor's field of view. Call the method with the state set to false to simulate that there's been no activity for some time. The motion sensor interacts with other sensors and appliances. If any motion is detected while the arming mode is set to away, meaning that nobody's at home, the alarm will trip immediately. Yet, if the owner is at home, the sensor turns on the lights rather than tripping the alarm. In case of inactivity, the motion sensor will switch off the lights to save energy, but only if the alarm is off. If the alarm has been activated, we'd rather keep those lights on. Finally, we notify the thermostat about motion state changes. I use optional chaining to call the onMotionStateChanged method of the optional thermostat property. If the thermostat property is nil, the call returns nil, otherwise, the call succeeds. The Lighting class is quite straightforward. It has a private lightOn Bool property that can be queried or set using the isOn property. Next, let's check out the Thermostat class. It has two properties, airConditioner and heater, as it must access the heating and cooling equipment. Also, it has a tempMin and a tempMax property. These properties represent the ambient temperature range for our home. The initializer lets callers provide the AirConditioner and Heater instances. The tempRange tuple parameter allows setting the temperature range. It has a default value for convenience. The onTempChanged method simulates a change in the room's temperature. If the temperature falls within the desired range, the thermostat checks whether the air conditioner or the heater is on and turns them off. If the temperature is less than tempMin, we switch on the heater, and if it gets hot in there, the thermostat turns on the air conditioner. You may recall the onMotionStateChanged method. We called it from the motion sensor. This is used to switch the energy saving mode on or off depending on somebody's presence in the room. The method sets the isEnergySaving property, which in turn updates the energy saving mode of the connected heating or cooling appliances. The Heater class is quite simple. We can turn it on or off using the isOn property. Setting the property updates the private isHeating property. Also, we print a console log to track the heater state. The isEnergySavingMode property sets and prints the state of the energy saving mode. The AirConditioner has a similar implementation. Next, we'll test our smart home system.

What's the Problem with v1.0?
Now let's test our smart home system. I'm going to create a couple of sensor and appliance instances. First, those that don't need initializer arguments. Let's start with an Alarm instance, then let's create an object that represents the lighting. We'll also need a Heater and an AirConditioner. Next comes the carbon monoxide detector. In its initializer, I'm going to provide the Alarm instance. Then I create the Thermostat. I provide the air conditioner and the heater. We also need the motionSensor to complete our smart home system. It needs the alarm, the lighting, and the thermostat. Alright, now let's simulate some motion. I'm going to set the state parameter to true. If we run our demo now, it shouldn't trigger the alarm. Indeed, as we see in the console, the sensor detected the movement and turned on the lights. Yet, the alarm stays silent because the arming mode is set to state by default. Also note that the motion sensor turned the energy saving mode off for the air conditioner and the heater. Next, let's simulate the change in the ambient temperature. I'm going to use the thermostat and call onTempChanged with the temperature set to 63 degrees Fahrenheit. This should switch on the heating. Let's see. Indeed, the smart home turns on the heating. Note that the energy saving mode is turned off. This is because we also simulate motion by calling onMotionStateChanged with the state set to true. Now let's say that the temperature increases. By passing in 64 degrees Fahrenheit, the temperature will fall within the desired range. This should switch off the heater. Then we simulate that there is no movement by calling motionSensor onMotionStateChanged with the state set to false. This should set the heating and cooling appliances to energy saving mode. Alright, this works as expected. How about testing the carbon monoxide detector? Let's simulate high carbon monoxide levels first. The sensor tripped the alarm. Now let's turn the carbon monoxide levels back to normal. Since the carbon monoxide levels are normal, the alarm stopped. Now I set the alarm's armingMode to away. While the alarm is armed, the sensor detects motion. This will trip the alarm. Alright, so our system works as designed. Yet, this solution comes with too many coupled objects. Let's take a look at the MotionSensor for example. It references the alarm, the lighting, and the thermostat type. Reusing the MotionSensor in another project is only possible if we bring over also the connected types, and the project is hard to extend too. The number of connections keeps increasing with every newly added sensor or appliance. The logic that needs to be added to a particular type can get out of hand too. In the next video, we're going to refactor the project. We'll get rid of all these dependencies between the types that form our system.

SmartHome v2.0 - Defining the Protocols
Alright, let's refactor our smart home system. We'll get rid of all the dependencies between the sensors and the appliances. In the revamped version, we'll have a mediator. All our types will interact only with this middleman. Alright, let's switch to Xcode. I started by defining a protocol that represents the appliance. So I'm going to call it Appliance, protocol Appliance, and Appliance should be able to receive events. So I'm going to declare a method requirement called receive. Next, I define the Event protocol. It has two properties, a message of type String and a state of type Boolean. The letter indicates an on/off state. Both properties are gettable and settable. Now let's define the Mediator protocol. The Mediator has two responsibilities, receive notifications from sensors and send notifications to receivers. Let's first declare the notify method requirement. The notify method should have two arguments, the sender of type Sensor and the event itself, which is of type Event. The Mediator needs to keep track of the potential receivers. For this, I add a register method. The method takes a parameter called receiver of type Appliance. We also need the sensor protocol. Each sensor should communicate with the mediator, so I add a property called Mediator. This property is read only. Callers can provide the mediator using the initializer.

Refactoring the Sensors
Now that we have the protocols, let's adapt our classes. I start with the carbon monoxide detector. First, I'll make it adopt the Sensor protocol. We get an error since the class doesn't conform to the Sensor protocol yet. I let autocomplete help me out here. Let's implement the init method. Our aim is to get rid of the tight coupling between classes, so let's simply delete this property. Next, I'm going to delete the initializer too. Now instead of calling the alarm's methods, we need to communicate with the mediator, so I'm going to delete this line here and notify the mediator instead. The sender is the carbon monoxide detector instance itself, so I use self. But we don't have a concrete event type yet, so let's create it. I define the struct called SensorEvent. It must conform to the protocol Event. Autocomplete can create the missing steps for us. Now we can go back and complete the implementation of the onCOHigh method. So the event is a SensorEvent, the message is alert, and the state is true. This is how we signal that the carbon monoxide level is high. Next I'm going to refactor the onCONormal method too. First let's remove this line and call the mediator. notify instead. Again, the sender is this instance, so I just put here self, and for the Event, we'll again use the SensorEvent. The message, message, and the state in this case is false, which indicates that the carbon monoxide level is normal. Alright, we just got rid of one dependency. Now the carbon monoxide detector doesn't depend on the alarm type anymore. It only communicates with the mediator. Next comes the motion sensor. I add the Sensor protocol conformers, and let's add the missing stubs too. I'm going to remove all the references to other sensors, alarm, lighting, and thermostat. And let's remove also the initializer. Now let's fix the onMotionStateChanged method next. I'm going to remove most of the code, and finally notify the mediator. The message is status, and the state is the state received as argument. The implementation became shorter, but this is not the only benefit. The motion sensor isn't tightly coupled anymore with the alarm, the lighting, and the thermostat. Nice, isn't it? What's next? The thermostat. We proceed as usual. I'll make it conform to the Sensor protocol. Let's add the missing stubs, the usual code. Let's get rid of the airConditioner and heater properties. We don't need the initializer either, at least not to initialize the airConditioner and the heater instances because we don't have them anymore. But we still need to let callers provide the temp range, so I modify the initializer. I just remove the airConditioner and the heater parameters and add a mediator instead, and let's keep the tempRange. It's time to simplify the onTempChanged method, so I'm going to get rid of all the obsolete code. We need to communicate with the mediator using event. I'm going to define a new type to represent a change in the temperature. Let's call it TemperatureChangedEvent. I'll add a third property called temperature. We need a way to tell whether the temperature is within the desired range or not, so for this I'm going to define an enum. The TempState enum defines three cases, high, low, and normal. Alright, now let's get back to the onTempChanged method. So the event should be the newly created TemperatureChangedEvent. The message is Temperature changed. The state is not important in this case, so let's just set it to true. But the temperature should be set, so let's do this now. I'm going to create a variable and initialize it with a TempState normal. If the temperature is within the desired range, then I'm going to set TempState to normal. If it's below the minimum, then the TempState should be low, and in this case, the TempState is obviously high. And finally, we could complete the notify call. Since the motion sensor doesn't refer the thermostat directly, we can't remove the onMotionStateChanged method. Now the isEnergySaving property doesn't need this code anymore, but we need to notify the mediator. The sender is self. Now for the event, we'll need a dedicated event, so let's create it. I'm going to call it EnergySavingEvent, and again it's a structure which adapts the Event protocol. Let's add the stubs, and now let's complete our method. And the state is newValue. We'll continue with the alarm.

Revamping the Appliances
The alarm is a receiver, not a notification sender, so we need to make it conform to the appliance protocol. But instead of making the class adapt the protocol, I'd rather create a type extension. Now let's add some logic to the autogenerated method. The received event's state tells whether the alarm should be activated or disabled. So if the event state is true, I'll remove the trigger method with the message, and if the state is false, then I call disable. Next comes the Lighting class. We'll use extensions also in this case. Conforms to Appliance. Now the implementation in this case is even simpler. Next comes the heater. Again, I'm going to use an extension. Make it adapt the Appliance protocol, and let's create the method stub. Now the heater may receive two kind of events. Let's handle the temperature event first. If the temperature is in the normal range and the heater is on, we'll turn off the heating, and if the temperature is low, we turn on the heater. So for everything else, we'll just print the warning. If the heater receives an energySavingEvent, we'll just update the energySavingMode property. If the current state is different from the one we received, then we are going to update it. Now the logic is very similar for the air conditioner. The only difference is that we must turn on the air conditioner if the temperature becomes high. So I'm going to simply copy and paste this code, and make it an AirConditioner extension instead. We'll switch on the air conditioner if the temperature is high. As you may remember, the thermostat should intercept motion sensor events, so I'm going to make a Thermostat extension and make it adopt the Appliance protocol. Let's add those stubs. That's only the receive method, and here we just set the isEnergySaving property.

SmartHome Hub - The Mediator
Alright, we're almost done. The only missing piece is the Concrete Mediator type. To save us some time, I've gone ahead and implemented it. Our Concrete class is called SmartHomeHub. It has a private list that holds the Appliance instances. Callers can add appliances using the register method. The notify method gets called from our sensors. The method receives a sender and the event. If the sender was the carbon monoxide detector, the mediator notifies the alarm by calling its receive method. The carbon monoxide detector does not need to communicate with other appliances, so we're done here. Now, motion sensor events should be propagated to alarm, lighting, or thermostat instances. If motion is detected while the Alarm's armingMode is set to away, the alarm must be tripped. Also, the lights are switched on or off based on motion events and the thermostat also receives motion events to set the energy saving mode accordingly. The Thermostat sends temperature change events and energy saving notifications. The mediator sends these events to the Heater and the AirConditioner. Finally, let's test our redesigned system. We instantiate the appliances as usual, but we'll also need a mediator instance. I'm going to delete these lines because they just cause compiler errors, and let's register all the appliances with the mediator, the alarm, the lighting, the heater, and the air conditioner. Next we instantiate our sensors. Note that we have to pass in the mediator and the MotionSensor. Let's remove this line. Now the thermostat is both a sensor and a receiver, so I register it with the mediator. We're going to use the same code for testing that we used in our 1. 0 version. Alright, now let's run the test. There's a small error, so let's fix it quickly. I'm going to assign some default values for the tempMin and the tempMax properties. Let's make this 64 and the tempMax 77. Alright, let's try it again. The output is the same, yet there is a huge difference. Our sensors communicate only with the mediator. The mediator processes the events and notifies the appliances as needed. With this, we finished our demo. This was a practical example of how to refactor an existing system using the mediator pattern. This is not the only way to do it though. As with the other patterns, you're free to adapt it to your needs.

Summary
Here's a brief summary of the mediator design pattern. The mediator promotes loose coupling. By reducing the dependencies between our types, they can be reused easily. All the objects should communicate with the mediator instead of talking to each other directly. The mediator acts as a middleman and encapsulates all the required control logic. Now this can also become a problem. Since the mediator contains all the control logic for the entire system, its code may become overly complex. We can prevent this with the proper design and by applying further patterns. In the next module, we'll talk about another very useful pattern called memento.

Memento
Overview
In this module, we're going to talk about the memento design pattern. First, we'll take a closer look at the pattern and why it is useful. Then, we'll implement the practical demo in Swift. I'm going to illustrate the memento pattern by creating a solution for saving and restoring game states. So, what's this pattern about? The memento lets us take a snapshot of an object's important state. When implementing this pattern, it is important to keep the safe state external to the object. The object's internal state is not exposed, thus we don't break encapsulation. The captured state is kept in a memento object. Later we can restore the object with this saved state. Now, let's take a look at the UML diagram of memento design pattern. We've got three distinct roles. The originator, this is the object that we want to restore to a given state. It has two methods. The createMemento returns a memento instance, which holds the information needed to reset the originator to that state. And the restore method, which takes the memento parameter that includes the previously saved state. The restore method resets the originator to this state. The memento is quite simple, it has a state. This can be a built-in or a custom type that can hold the originator's state; it doesn't contain any further logic. The caretaker provides the save and restore functionality. It asks the originator to save its state or to return to a previously saved state. The caretaker keeps track of all the previously created mementos. We'll see soon how all of these come together in the demo app. Here's the formal definition of the memento design pattern. The memento captures the important state of an object without exposing its internal data. The saved state can be used to reset the object to a previous state if needed. The memento can be used to implement undo and redo operations. Next, I'm going to show you how to implement the memento design pattern in Swift.

Memento Demo - Saving and Restoring Game State
In this demo, I'm going to show you an example of applying the memento design pattern. We'll implement the solution for saving a game state at a given point in time. We'll also provide the ability to restore the game to any of the previously saved states. Now let's switch to Xcode. We'll implement this demo as a playground project. You can download the finished project along with the other exercise files. So here's a class called GameScene. This class represents a level in the game. Our task is to add features for saving and restoring the game state. The GameScene class has a couple of private properties, score of type UInt, progress of type Float, and sessionTime of type TimeInterval. There's also a lazily loaded session timer, which increases the session time every second. The GameScene class has an initializer that simply sets the properties to their default values. The start method starts a session timer. First, we need to add the timer to a run loop. Then, we can start it by calling the timer's fire method. Also, we have two public computed properties for getting and setting the score and the progress. The class has also a custom description provided through a type extension. This lets us bring the level progress, the player score, and the session time. Alright, so let's start implementing our solution. I start by defining the protocols for the rows of the memento pattern. First, the memento protocol. It has a single property called state. I declare a place for the type for the state using the associatedtype keyword. The property is getable and settable. Next, I create the originator protocol. It defines a method that creates a memento; let's call it createMemento. Now, we can't simply return the protocol. The memento protocol has an associatedtype, thus it can be used this way. I had to declare a placeholder type of type Memento. We also need a second method to apply a previously saved state. The method takes a memento instance as input. Alright, we're done with the originator protocol. The last protocol represents the caretaker. I declare an associatedtype and add the originator type constraint. We need the method to save the state of the originator. Let's call it saveState. Callers must provide the originator and the unique identifier for the saved state. I use the AnyHashable type for the identifier. AnyHashable is a type-erased hashable value. This means that we can replace it with any value that confirms to hashable protocol. We also need the method that restores the originator to a previously saved state. The restoreState method takes the originator and the state identifier as input parameters. Alright, now let's start implementing the save and restore functionality. First I'm going to declare the GameMemento, which is a struct that adopts the memento protocol. It should have a state property, and we must also declare a type for this. As you may recall, I used an associatedtype for the state in the protocol. So let's call it ExternalGameState, and let's create a structure for it. Let's think about the state that we need to save and restore. The GameScene class has three properties, the score, the progress, and the sessionTime. The sessionTime is used only for internal housekeeping. It gets constantly increased while the game is running, so we don't really want to externalize or change it. When we restore the game to a previous state, the score and the progress should be reset though. I'm going to declare two properties that reflect this, the playerScore of type UInt and the levelProgress of type Float. Next, we need to make the GameScene adopt the originator protocol. I'm going to introduce a type extension instead of modifying the class directly. Sometimes we don't even have access to the original code, but with type extensions we can still enhance the type. Alright, so let's create our GameScene extension. First I define the createMemento method. It returns a GameMemento instance. I capture the currentState in an ExternalGameState object. Finally, I return a GameMemento initialized with this state. Next, I implement the apply memento method. We get the state to be restored from the memento passed as input. Then, we set the score and the progress. The only missing piece is the concrete Caretaker type. I'm going to call it GameSceneManager. GameSceneManager is a final class that adopts the caretaker protocol. Now let's add the missing methods. The saveState method accepts an originator of type GameScene. I call the originator. createMemento to take a snapshot of the GameScene's current state. The GameSceneManager needs to store this state. I declare a lazy private dictionary called snapshots. The key is of type AnyHashable, and the values need to be GameMemento instances. Now I can add the snapshot to the private dictionary using the identifier as a key. We also need to implement the restoreState method. The restoreState is simple. First, we need to check whether we've stored a memento for the given identifier. If it is found, we call the originator's apply method with the memento. Finally, let's add an initializer. Alright, now let's test the solution with just implementing it. First, I create a GameScene instance and start it. How about saving the GameScene's initial state. We'll need the caretaker that is a GameSceneManager object for that. Now I can save the state; let's call it initial. I bring the GameScene's current state to the console. This will let us track the state changes. We're using a playground. To simulate the real world situation, I need to introduce some delays between the state changes. I'm going to use the DispatchQueue asyncAfter method. Its closure gets executed after the time we provide in the deadline parameter. I'm going to update the game state after, say, 3 seconds. We just set the levelProgress and the levelScore. Let's save this state. I'm going to call the identifier snapshot_1, and again, let's bring the gameScene description to the console. I'm going to simulate another state change after 2 seconds using asyncAfter, just as we did before. I update the progress to 80 and the score to 10000. Alright, let's save this state too. Now let's restore the gameScene to previous state. After a 1-second delay, we'll call restoreState. The identifier tells which state should be restored. Let's first restore the initial state. After another short delay, we restore our game to another state. Now one more thing is missing. We're using asynchronous methods to introduce delayed cause. Currently, if you run the demo it would exit before performing any of the delayed methods. This is because the playground won't wait for the async calls to complete. We need to tell the playground page to continue execution. For this, I need to import the Playground Support framework. Then, I set the current PlaygroundPage needsIndefiniteExecution property to true, and after the last async call's closure is executed, I let the PlaygroundPage finish its execution. Now let's run the demo. The state changes as we update it. When we restore a state, the level progress and the score are set to the saved values. The session time remains unaffected though. In our test code, we've been using only the GameScene instance and the GameSceneManager. The originator state, the memento, and the external game state were not exposed to the client.

Summary
Let's summarize what we know about the memento pattern. The memento pattern captures the important state of an object into a memento. This memento can be used to restore the object at a later date. The pattern is implemented correctly if the originator's internal state is not exposed to the client. Common pitfalls. Saving and restoring the state of a complex object may be time consuming. You should carefully consider performance implications when implementing the memento pattern. Another frequent problem is exposing the originator's internal details, thus breaking encapsulation. The client should rely solely on the caretaker to save and restore the state of the originator. Alright, so this was the memento pattern. In the next module, we're going to talk about the observer pattern.

Observer
Introducing the Observer
Let's talk about another behavioral design pattern called observer. If you've implemented an iOS or a Mac app, you've probably used the observer design pattern already. I'll start by introducing the concepts surrounding this pattern. Then, I'm going to implement two demos that are based on the observer. First, we'll create a virtual auction application where bidders get notified when the bid changes. Then, I'm going to refactor the demo to use the built-in NotificationCenter. Alright, so what's the observer pattern about? Basically, it's a way of notifying a group of objects about state changes in another object. The observers subscribe to receive notifications and the subject updates them when its state changes. The observer achieves this while keeping the subscribers independent from the subject's implementation. All of these objects remain loosely coupled. Here's the class diagram of the observer pattern. We've got an object referred to as the subject. This subject sends the notifications; it maintains a list of subscribed objects otherwise know as observers and notifies them of changes in its state. The observers need to subscribe to receive notifications from the subject. Here's a brief definition of the observer pattern. The observer allows subscribers to get notified about changes in another object without being tightly coupled to the sender. In the next video, we're going to implement an observer-based demo in Swift.

Auction Demo - Using the Classical Observer
In this video, you can follow me as I implement an auction demo. We'll have an object that represents the auctioneer. The auctioneer updates the bidders when the new bid is accepted or when the reserve price has been met. My aim is to keep the auctioneer instance independent from the objects that represent the bidder. We'll start by defining the protocols. First, I define the Observer protocol. It has an update method. I add a notification parameter. Let's make it a place order type. As usual, I'm going to use the associatedtype keyword. Next, I define the Subject protocol. As you may remember, the subject allows observers to register and unregister, so I created the attach and detach methods. These methods will change the state of the instance, so both are mutating. The subject also needs a method to notify the observers. Let's continue with the concrete types. First, I implement the structure called Bidder and I make it adopt the Observer protocol. Now I need to implement the update method. This method takes a notification parameter. Let's define the concrete type. I create a struct and call it BidNotification. It has two properties, the bid of type Float and the custom message of type String. Let's make the message optional. Now I can go back to the update method and replace the type for the notification parameter. I add an additional property called id. This is going to identify each bidder. It is of type String. Now, the update method just prints a console log which contains the id, the bid, and the message if the caller provided one. Next, I create the Auctioneer type. The Auctioneer is a struct which adopts the Subject protocol. Now I need to add the missing methods, attach, detach, and notifyObservers. To store the subscribed observers, I define a private array that hold instances of type Bidder. The attach and detach methods should take an argument of type Bidder. The attach method will append new observers to the bidders private list, and the detach method remove them if found. I used the array filter method to create a new list. The filter method takes a closure. Here we specify that we want to keep only those elements that have an ID that's different from the input parameter's ID. Now the notifyObservers needs to notify the subscribers by calling their update method. First, I'm going to add a couple of new properties. Then, I call the update method for each observer. I add an initializer that lets us set the reservePrice and optionally the initialBid too. Now let's test what we've implemented. I create an Auctioneer instance first, and now I'm going to create a couple of Bidders. Next, I attach the bidders to the auctioneer. If I set the bid, the observer should be notified. Now let's assign the second value; this works nicely too. All observers were notified. Let's check what happens if we detach an observer. Indeed, after detaching it, it doesn't receive the notifications anymore. Now let's set a higher bid. The last bid meets the reserve; the bidders are informed accordingly. In the next video, I'm going to revamp the demo using Notification and NotificationCenter.

Auction Demo Revamped Using Notification and NotificationCenter
I'm going to refactor our auction demo. I'll use the Notification and the NotificationCenter. We won't need the protocols, so I just removed them. I need to also remove the protocol conformance, and we don't need the update method anymore. Instead I'm going to add an initializer. Its main purpose is to register the instance with the NotificationCenter. And now I'm going to invoke the default NotificationCenter's addObserver method. For the notification name, I'm going to declare a struct. Although I could use simply a string, using a struct provides a namespace for our constants. Now back to our addObserver method. For this demo, the object and the queue parameters can be nil. And finally, the closure. The closure is called whenever the notification gets broadcasted and received. We can send custom keys and values through the userInfo dictionary. I'll use the keys bid and message for the corresponding values. Now let's continue with the auctioneer. I get rid of the attach, detach, and notifyObservers methods. Instead of calling the notifyObservers method, I'm going to send a notification. I create a Notification with the bid and the custom message. Finally, I call the NotificationCenter's post method to send the notification. The rest of the code is unchanged, excited that we don't need to attach the observers, and we should use NotificationCenter's removeObserver method. Now let's run the demo. It should produce the same result as before the refactor.

Observer - Summary
Here's what we know about the observer pattern. The observer design pattern allows objects to subscribe to receive notifications about changes in another object. The NotificationCenter, also known as subject, updates the observers when its state changes. There is no tight coupling between the subject and the observers. The subject only knows that the receivers adopt the observer protocol. No further implementation details are needed. This loosely coupled design lets us easily add or remove observers. There is no need to modify the subject when creating new observer types. The only requirement is to make the new type conform to the Observer protocol. Now let's talk about some of the pitfalls of this pattern. One of the potential issues is related to observers being kept alive by the subject. When an observer is about to be released, we should detach it from the subject; otherwise, the subject will keep the observer alive and it's going to update it long after it should have been released. This may cause undesired side effects and all kinds of weird bugs. Another pitfall with this pattern is allowing the observers and the subject to become tightly coupled. The observer pattern is implemented correctly if the subject only caused the observer's update method. In the next module, I'm going to talk about the state design pattern.

State
The State Design Pattern
The state design pattern is the object-oriented solution to monolithic conditional statements. First, I'm going to talk about the theory behind this pattern. Then, I'll refactor a demo application using the state design pattern. We'll end up having a better, easier to maintain version. Alright, so let's take a look at the state design pattern. The core idea is to create an object-oriented state machine. The state design pattern can be applied successfully to remove complex conditional logic from a software system. The conditional behavior gets encapsulated into separate types. Having dedicated types results in a more flexible system and makes our code easier to understand. Besides, adding new states or updating existing ones will require less effort. This UML diagram describes the players involved in the state design pattern. The context exposes the public interface to the callers; it delegates requests to its state. The state protocol defines the common interface for all concrete states. Finally, the concrete state types implement the behavior associated with the state of the context. Each state type provides its own implementation for a request, thus the context behavior will be different whenever its state changes. So, here's the formal definition. The state design pattern allows an object to behave differently when its internal state changes. In the next video, I'll show you an example of applying the state pattern to an existing code base.

ATM Demo - Refactoring a Project Using the State Pattern
In this demo, I'm going to walk you through the process of refactoring the implementation of an ATM simulator using the state design pattern. My aim is to get rid of all the conditional code from the ATM class. Besides, the revamped design will be easier to maintain and enhance. This activity diagram models the simplified flow of an ATM transaction. You insert your card, enter your PIN, and if everything goes well, you receive the requested cash. The following Swift playground project shows a functional, yet not ideal way of implementing this flow. So, let me briefly explain the code I'm about to refactor. The ATM is a public final class. It has two public methods, enter pin, which simulates when you're prompted to enter your PIN code after inserting your card, and withdraw amount for entering the amount of cash you want to withdraw. The enter pin method performs a basic PIN check. If the provided PIN differs from the predefined value, it displays an error message and returns. Otherwise, the method sets the value of the isPINValid property to true. I use the isPINValid property in the withdraw method. If it's false, the method returns. If the user entered the valid PIN, I perform some validations. The amount should be a positive value. Then there's a simple balance check. That's all. So, let's test our ATM simulator. First with a valid PIN. Alright, now with an invalid PIN. And let's test the balance check logic too. Although this code works as expected, it's far from perfect. We've got a lot of conditional logic in the ATM class already. As we add new features, the complexity of our code increases. So, let's solve this problem using the state design pattern. For now, I leave the ATM class as it is. I start by defining the common interface for our states. I call it ATMState and declare it as fileprivate. This is to prevent exposing it to callers. This is the protocol that declares the functionality for all the concrete state types. So, we'll need the method for entering and validating the PIN. Validate pin takes a pin parameter of type String. We also need the method for withdrawing the money; it has a parameter called amount of type Float. The method returns the result of the execution as a Boolean, and I add another method for marking the end of the transaction. I've been using protocol extensions throughout the course; they are a very nice way of providing default behavior for protocols. States should implement only the functionality they are responsible for. For the rest, the default implementation will be invoked. Thus, the default implementations shouldn't do anything meaningful. For demonstration purposes, I write a log to the console stating that the method is not implemented for the given type. Now let's start defining the concrete states. I start with a state called IdleState. It represents the state when the ATM is not used. I continue with the EnterPINState. Now, there are different ways to implement the state pattern. One approach would be to embed the state changes in the context that is in our ATM class. Another approach is to let the state types handle the state transitions. I'm going to use the second approach to keep our ATM class clean and simple. For this, the state needs to access the context to change its state, so I'm going to declare a context property of type ATM. The EnterPINState implements only the validate pin method. The method performs a simple PIN validation. If the PIN is invalid, I print a message to the console. In this case, we should stop the flow. Now I implement a type for the TransactionCompleteState. Also in this case, we need the context property to update its state. This state is going to implement the transactionCompleted method. I compose a message based on the success parameter and print it to the console. And finally, I need to update the state of the context to IdleState. The only issue with this is that the context, that is the ATM class, has no state property yet. So, let's go back to the ATM class and add a state property. Now I can update the context. state to Idle. So, we've just finished the TransactionCompleteState, but we are not ready with the EnterPINState's validate method yet. So, let's go back and continue where we left off. I can now update the context. state to TransactionCompleteState. Then, I call the state's transactionCompleted method with the success argument set to false, which indicates that there was an issue. If the PIN entry was successful, we should allow the user to withdraw the money. It looks like we need to another state, so I'm going to create another struct, let's call it WithdrawState. It adopts the ATMState protocol. This one also needs to access the context, so I declare the property as usual. I also add the static property availableFunds; we'll use it to check the balance. The WithdrawState implements the withdraw amount method. First, I perform some validation steps. If the amount is negative or there are no sufficient funds, I switch the context. state to TransactionCompleteState. Then, I call the transaction completed with the success set to false. As you may recall, the TransactionCompleteState will then change the state of ATM to idle. If we pass the validation steps, I simply subtract the amount from the available funds. Then, I switch the context. state to TransactionCompleteState. And finally, I mark the transaction as completed successfully. Now we can refactor the ATM class too, so let's remove the obsolete parts. We don't need any of the old properties, so I'm going to simply delete them. I can also delete the implementation of the enter pin method. Here I set the state to EnterPINState and call the state's validate method. The next is the withdraw method. I get rid of the all the code. When clients call the withdraw method, the ATM should be in the right state; otherwise, the withdraw method won't do anything. I call the state. withdraw method. Now, let's run our tests. Everything works just like before. There is a huge difference though. This design is easier to extend. We got rid of all the conditional logic from the ATM class. Instead, we've got dedicated states that encapsulate the required logic and the state changes. This approach produces a flexible design and cleaner code. The benefits become obvious as we add new functionality.

Summary
So, let's recap what we know about the state pattern. The state design pattern allows objects to behave differently as their internal state changes. It can be applied successfully to remove monolithic conditional logic from a software system. To implement the state pattern, you need to identify the steps that cause changes in the behavior of an object. Then, extend these steps and encapsulate them into dedicated state types. One of the common pitfalls is exposing the states to clients. The state types should be used exclusively by the context, whereas clients should interact with the interface provided by the context. As you may remember, in our demo I made the context public while declaring the state types as fileprivate. In the next module, I'm going to talk about the template method design pattern.

Strategy
The Strategy Design Pattern - Overview
The strategy pattern lets you change the behavior of an object without modifying its implementation. I'll show you in a moment how it works, but first let's take a closer look at the pattern. After discussing the details and the reasons behind using the strategy, I'm going to show you a real world application of this pattern. We're going to implement the versatile logger. The logger will support console and in-memory logging, and it will be easy to extend with new destinations. The strategy pattern allows us to change the behavior of a type by switching algorithms. The pattern works by defining a common interface for a family of algorithms. Each algorithm gets encapsulated in its own strategy type. The client only depends on the interface, so it can vary the algorithm by simply switching the concrete strategy object. To make it easier to understand, let's take a look at the following UML diagram. We've got the context, which delegates the client request to its strategy. The strategy is a protocol; it defines a common interface for all concrete algorithms. The concrete strategy types implement a specific algorithm. Clients instantiate the context with a concrete strategy object. The algorithm can then be updated by applying a different strategy instance to the context. The strategy pattern is about decoupling the algorithm implementation details from the type that uses it. This allows changing the object's behavior at runtime by switching algorithms.

Implementing an Customizable Logger Using the Strategy
In this demo, I'm going to implement the logger component with support for multiple log destinations. I rely on the strategy pattern to chose between logging behaviors. Now, let's switch to Xcode. First, I define the LogStrategy protocol. It declares a log method for writing single log entries and a retrieveLogs method to fetch the logs. Then, we need the logger context. That's the type that provides the client-side interface. I make it a final class and call it LoggerContext. The LoggerContext needs a strategy instance. Client requests get delegated to this strategy object. We have two choices when setting the strategy. One option is to allow clients to provide it during initialization and restrict changing it later on. Another possibility is to let clients change the strategy any time. This can be achieved by providing a setter. For this demo, I pick the first approach. The strategy can be applied only once during initialization. The logger needs to provide a way to write log entries, so I define the method write entry, and we call the strategy object's log method to record the log. We also need to retrieve the logs. I simply declare a calculated property, which returns an array of Strings. Although this is acceptable for our demo, for real world applications it should rather use a string-based solution. Since the logger may be used for multiple threats, I need to protect it from concurrent access, so I declare a serial DispatchQueue. By default, the queue will be serial. Now let's make our write method threat safe. I embed a strategy. log call in the queue sync closure. The sync method blocks the queue and won't execute new requests until it finishes the current one. Know that there are more sophisticated techniques to prevent concurrency issues. I discuss these techniques in detail in the Singleton module of the Creational Design Patterns in Swift course. Next, I add the same protection to our calculated property. Alright, now let's implement some concrete strategy types. I start with the ConsoleLogStrategy; it should adopt the LogStrategy protocol. So we want the console logger behavior, thus the log method just prints the log to the console. As for retrieving the logs, it doesn't really make sense for a console logger, so I'm going to simply return nil. Next, let's implement the InMemoryLogStrategy. It must also adopt the LogStrategy protocol. I'm going to add the stubs. Since this is an in-memory logger, we need the buffer, so I'm going to declare an array. The log method is straightforward. It appends each new log entry to the logEntries array. And the retrieveLogs is even simpler, it just returns the logEntries. Finally, let's try out our logger. I start by creating a logger instance. I need to choose a strategy during initialization. Let's use a console logger first, then I write a couple of log entries, and finally, I retrieve the logs. Let's run it. Now I switch to the in-memory logger. I only need to replace the strategy parameter. This design is easy to extend. If we need to add a new strategy, we only need to create a new concrete strategy type. The implementation of the logger context remains unchanged.

Summary
So, let's recap what we know about the strategy design pattern. The strategy should be used if you need to implement algorithms that need to be used interchangeably. The algorithm is decoupled from the type that uses it. The context only sees the protocol, which allows clients to easily switch between the various implementations. Another benefit of the strategy pattern is that it lets us add new algorithms without modifying the class that uses them. The strategy pattern is so straightforward that there are no pitfalls I could mention. Next, I'm going to talk about the template method design pattern.

Template Method
The Template Method Design Pattern - Overview
In this module, we'll take a look at the template method design pattern. The template method defines the steps of an algorithm and allows some of the required steps to be modified. As usual, we'll talk first about the concepts surrounding this pattern. Then, I'm going to walk you through a demo, which implements the template design pattern using a protocol-oriented approach. So, when should you use the template method? The template method pattern is useful when you need to allow third parties to provide or replace some steps of an algorithm while other parts remain fixed. The fixed functionality is provided by the base type and can be overwritten. For the steps that can vary, the base type can provide so-called hook methods. The hook methods may have default or empty implementations in the base type. Clients can extend or override the behavior provided by the hook methods. The hook operations get called at specific points. The template method pattern allows extensions only at these predefined points; thus, clients can override certain steps of an algorithm without modifying its original structure. We can briefly summarize the pattern as follows: The template method allows specific steps in an algorithm to be replaced by clients without modifying its original structure.

Implementing XML and JSON Converters Using the Template Method
In this demo, I'm going to show you the protocol-oriented way of implementing the template method design pattern. Instead of using a base class to define the skeleton of the algorithm, I'm going to start with a protocol. With protocol extensions, we can implement the fixed parts of the algorithm. Let's get started. We'll start with the following two structures. Contacts has a property, which can hold an array of contact instances. The Contact structure has three properties, firstName, lastName, and phone. Both structures adopt the Encodable protocol. The Encodable protocol conformance makes our data types encodable to external representations, such as JSON or XML. Let's assume that we need to display instances of type context as JSON and XML data. I'm going to define the required methods in the protocol. PrettyPrintable exposes the method displayed to the callers. The display method should work with any object that adopts the Encodable protocol; thus, I define the method as generic, and I need to enforce the encodable type constraint. The syntax for type constraints is simple. You place a single class or protocol constraint after the type parameter's name, separated by a colon. Now we can use a place for the type Value in the method's parameter list. Next, I define the methods that represent the fixed and the customizable steps of the algorithm. We need a way to encode the context. There are many ways to encode an object. So, this is a functionality that can vary, a feature that should be provided by conforming types. In other words, this should be a hook method. I call the method encodeHook. It is a generic method that accepts arguments of type Encodable. The method returns data. The conversion can fail, so the return type is optional. Next, we need a method that creates a formatted string from the converted data. Converting data to strings is a common task that doesn't require customization; therefore, this step of the process is fixed. The formattedString method takes an argument of type data. Converting data to a string may fail, so the return string is optional. The last method allows displaying the string representation of the converted value. I'll make it a hook method. DisplayHook can be customized by adopters of the PrettyPrintable protocol. Now that we have the protocol, let's implement the default behavior using a protocol extension. The display context method is the one that will be used by clients. It relies on the other methods that represent the fixed and the customizable steps. It calls encodeHook to convert the context and the formattedString method to create a string ready to be displayed. If any of these methods fail, I return nil. I call the displayHook method and finally return the formattedString. Now, I'm going to provide default implementations for the other methods. EncodeHook should be implemented by adopting types; hence, the default implementation returns nil. The method formattedString is a fixed step. I return the result of converting the data to a UTF-8 encoded string. Although displayHook is a customizable method, I provide a simple default implementation, which just outputs the input string to the console. Adopting types can override this behavior if they want. So, let's create the first concrete conforming type. The JSONDisplayable type adopts the PrettyPrintable protocol. I only override the encodeHook method. We need to encode the context parameter to JSON, so I need the jsonEncoder instance. I could create a local constant, but let's rather make it a lazy property. This will guarantee that it's only instantiated once when it's indeed needed. And now, I can encode the input argument using the jsonEncoder. The encode method may throw an error, so I'm going to handle the error as an optional value using try?. If an error is thrown, the value of the expression will be nil. Finally, I return the JSON-encoded data or nil if the conversion failed. Next, I create the type to display the context as XML. XMLDisplayable adopts the PrettyPrintable too, and I override the encodeHook method also in this case. I create a lazy property of type PropertyListEncoder. The output format should be XML. And finally, I return the instance. Now let's go back to the encodeHook method. I need to call the pListEncoders. encode method to convert the context to XML format. This method can fail, so I handle the error like we did in the JSONDisplayable class, and then I return the encoded data. It's time to test our solution. Let's create some contact instances. Then, I initialize the contacts object with the two contacts we just created. Let's try out the XMLDisplayable class. The output in the console seems to a valid XML. Now let's see the jsonDisplayable. This also looks fine. So, we implemented two classes that can convert and print any type as a nicely formatted XML or JSON string. By applying the template method design pattern, our concrete types can provide their own way of encoding an object that conforms to the Encodable protocol. The fixed steps of the algorithm are provided as protocol extensions.

Summary
In this module, we've been focused on the template method design pattern. Unlike the strategy, this pattern is not about replacing the entire algorithm, but rather about changing certain steps of an algorithm. The fixed functionality is kept in the base type and cannot be modified by subclasses or conforming types. For the steps that can vary, there are extension points also known as hook operations. Swift types and protocol extensions provide an easy, straightforward way to implement the template method design pattern. Pitfalls. Don't use this pattern if you need to allow changing the entire algorithm. For the latter, use the strategy pattern instead.

Visitor
Visitor - Overview
In this module, I'm going to talk about the visitor design pattern. After discussing the details of this pattern, we'll implement a shopping demo in Swift that will let us calculate the total price of unrelated products. So, let's talk first about the motivation behind using the visitor pattern. The visitor allows adding common behavior to unrelated types. It should be used if we cannot or don't want to change the source code of the given types. The visitor works without subclassing. Instead, it separates the new behavior into a dedicated visitor. The visitor must visit each object and performs required operations on that object's state. If a new functionality is required, you must only extend the visitor, or create a new visitor for that matter. That being said, I'd add that Swift type extensions make it easy for us to define new behavior without modifying the original type. In other words, type extensions render the visitor pattern obsolete. And finally, here's the definition. The visitor lets us add new common behavior to unrelated types without changing their implementation. In the next lecture, I'm going to implement the classical visitor design pattern first. Then, I'll show you the type extension base solution.

ShoppingCart Demo - Calculate Total Price of Unrelated Products
In the following demo, I'm going to show you a practical application of the visitor design pattern. We'll create a shopping cart demo that allows us to sum up the prices of unrelated items. First, I'm going to implement the classical visitor. Then, I'll you the type extension base solution. Alright, let's get started. We have a couple of unrelated products, Book, Computer, and Car. They have different properties for retrieving their price; itemPrice for Book, unitPrice for Computer, and stickerPrice for Car. Now, let's say that you buy these products online. The simplified shopping cart is represent by an array that can hold unrelated items. Now here's the challenge. How would you implement a function that calculates the total price of the items in the shopping cart? I'm going to implement the brute force approach first. The calculateTotalPrice function takes a heterogenous array as input and returns the total price as a Float. I declare a local price variable and initialize it to 0. Then, I iterate through all the items and sum up their prices. Since the elements in the array are different, I have to try to cast each object to all potential types. If the item is a book, its price can be retrieved through its itemPrice property, and if it's a computer, then I use the unitPrice property to get its price. If it's a car, I use the stickerPrice property. Finally, I print the result to the console. Let's run the app. The total price is accurate, yet our calculateTotalPrice function contains a lot of conditional logic. As we add new types, the number of required checks increases. I need to cast and check each object to add its price to the total price. The visitor patterns solves this problem by extracting the new behavior into a visitor type. The visitor has visit methods that can handle each and every type. So, I declare the Visitor protocol with a visit method for the type Book, Computer, and Car. The concrete visitor types need to operate on the subject state. To receive the right instance, the visitor pattern uses a technique called double dispatch. For double dispatch to work, each subject has to define an accept visitor method. I create a protocol that defines this method; let's call it Product. The accept method takes a visitor instance as an input argument. Calling the accept method ensures that the current subject gets chosen. For each subject, I implement the accept visitor method. I use type extensions to add this method to each type. Accept visitor calls the visitor's visit method with self as argument. This calls the correct visitor subclass and ensures that the right operation gets executed. The process is called double dispatch because of calling the accept and the visit methods. The double dispatch method invocation will make more sense in a moment as you will see it in action. Next, I create the concrete visitor type. PriceVisitor is responsible for calculating the total price. The visit methods will add the given type's price to the totalPrice property. Now, let's refactor the calculateTotalPrice function. First, I need to change its signature. Instead of an array of type any, the function accepts a list of products. This is required to access the accept method. I can now remove this code. Then, I instantiate the priceVisitor instance and call each item's accept method with the priceVisitor as argument. Now we can understand the double dispatch mechanism better. For each item, the accept method gets called. Say the item is of type Book. The Book object's accept method is invoked, which in turn calls the priceVisitor's visit method by passing itself as argument. This will invoke the PriceVisitor's visit item method that takes an argument of type Book. Finally, this adds the book's price to the total price. This is how the double dispatch works; hope it makes more sense now. By applying the visitor, the method not only became cleaner, but we won't need to modify it if we add new product types. So, this was the classical visitor pattern. Swift offers an even simpler way to solve the original issue. Swift lets us enhance any type using type extensions. This renders the visitor pattern obsolete as you'll see in a moment. So, let's go back to the original problem. Instead of dealing with the double dispatch mechanism used by the visitor pattern, I create a protocol that defines a common method for retrieving the price. The protocol CommonAttributes declares a single calculated property called price. Now, I can enhance each type through a type extension. I add the property to the Book type, the Computer type, and finally, the Car type. Next, I need to modify the array. It should contain instances of type CommonAttributes. I also need to change the signature of the calculateTotalPrice function. Since each element in the array has a property called price, I can easily calculate the total price. Basically, we've achieved the same result as with the classical visitor approach. Yet, Swift's type extensions provide a simpler way to accomplish the same. You should use extensions if you need to add new functionality to existing classes, structs, enums, or even protocols.

Summary and Goodbye
So, here is what we know about the visitor pattern. The visitor should be used to add new behavior to unrelated types. This is especially useful if you need to traverse collections of heterogeneous objects and perform related operations. Swift provides powerful new language features. Type extensions let us add new behavior to types without modifying their implementation. This renders the classical implementation of the visitor pattern unnecessarily complicated and obsolete. We're at the end of the three-part series on design patterns in Swift, but there's still a lot more that can you learn and understand about design patterns and Swift in general. Practice will help you in developing the required skills. Swift is a beautiful modern programming language which combines multiple programming paradigms. This gives you a lot of freedom and flexibility for designing and implementing your software systems. You can follow the object-oriented way, but you should definitely also try the protocol-oriented paradigm. Besides, Swift can be also used a functional programming language. It's a good idea to revisit the content of the three-part series on Swift Design Patterns now and again. You'll find new ideas and things that will have new meaning the second or even the third time around. Thanks for watching, and see you next time.

Course Overview
Course Overview
Hi everyone. My name is Karoly Nyisztor, and I'm happy to welcome you to my course, Design Patterns in Swift: Behavioral. I'm a tech entrepreneur, software engineer, and book author. Having been a professional iOS developer since 2009, I started using Swift right after its launch back in 2014. This course is an overview of the behavioral design patterns and the way they are implemented using Swift. It is the final part of a three-part series of courses on design patterns in Swift. The first two courses cover the creational and the structural design patterns. In this course, we're going to talk about the 11 behavioral design patterns. We'll start with the chain of responsibility, which stands at the core of the event handling in iOS and macOS. We're going to talk about the command pattern, which lets us package a method invocation as an object. We'll rely on the interpreter pattern to build a demo capable of processing navigation instructions and a calculator which uses complex expressions. We'll also talk about the frequently used iterator, observer, and the strategy pattern. These are just a few of the 11 patterns that we'll cover. By the end of this course, you should become very comfortable using the behavioral design patterns and applying them in your Swift projects. You will also gather a lot of Swift-related knowhow. Before beginning the course, you should be familiar with the basics of Swift programming. I hope you will join me on this journey to learn design patterns, with the Design Patterns in Swift: Behavioral course, here at Pluralsight.
