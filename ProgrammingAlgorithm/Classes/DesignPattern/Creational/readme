Hi everyone, my name is Karoly Nyisztor, and I'm happy to welcome you to my course Design Patterns in Swift: Creational. I am a developer, a book author, and a software architect. Having been a professional iOS developer since 2009, I started using Swift right after its launch back in 2014. This course is an overview of the creational design patterns and the way they are implemented using Swift 3. 0, Apple's latest iteration of their popular programming language. We begin the course with an introductory module about the history of design patterns, the values they provide, and their limitations. A brief Unified Modeling Language primer will introduce the concepts and the diagrams used throughout this course. Then we jump right into the creational patterns. First comes the singleton. We are going to talk about thread safety using Grand Central Dispatch, generics, and readers-writer lock. We then talk about the prototype pattern and concepts like the cloning of value and reference types, the difference between shallow and deep copying of objects, and under the hood optimizations like the copy-on-write. Next comes the builder pattern, followed by the factory method design pattern. We finish up the course with the abstract factory design pattern. By the end of this course, you should know how to implement creational design patterns in Swift. Before beginning the course, you should be familiar with the basics of programming, but you need not have actually worked with Swift itself. I hope you will join me on this journey to learn design patterns with the Design Patterns in Swift: Creational course here at Pluralsight.

Introduction & Prerequisites
Course Overview
Hello, before we jump into the patterns themselves, let me introduce you to some information that is useful not only for this course, but also for the courses that are going to follow covering the other design patterns. In this preliminary module, I am going to talk about the history of design patterns, the value they provide, and their limitations. A brief UML primer will follow where I introduce some of the UML concepts and diagrams used throughout this course. Finally, I will provide an overview of the design patterns organized by categories. In the second module, we talk about the creational design patterns. First comes the singleton. Then we talk about the prototype design pattern. Next comes the builder, followed by the factory method design pattern. We finish up the course with the abstract factory design pattern. For each design pattern, we discuss the following: when to use the given pattern, how can it be represented using UML, and finally, how can it be implemented using Swift 3. 0.

History of Design Patterns
In this video, I am going to talk about the history of design patterns, what are software design patterns, and why should you use them. In software development, we often see that the same problems repeatedly recur in multiple projects. After identifying these issues, software engineers develop solutions and best practices to sort them. Without a standardized way to address these common recurring problems, slightly different solutions had been reinvented over time. In 1994, four authors published a book called Design Patterns: Elements of Perusable Object-Oriented Software. The authors are Erich Gamma, Ralph Johnson, Richard Helm, and John Vlissides, also known as the Gang of Four. Because the name of the book is quite long, so book by The Gang of Four became a shortened name for it. The term design pattern became the official name for a strategy to deal with the common software development problem. The most important design patterns originate from the classic book written decades ago. These patterns are actively used in modern software development, and every object-oriented programming language provides the means to implement them. Design patterns, as we call them today, are the result of a long evolution process. They provide proven solutions to certain problems faced during software development. Understanding these patterns helps unexperienced developers to learn software design in an easy, fast, and secure way. The goal of this course is to help you identify and apply the patterns you need to address specific problems. Also, you will receive Swift implementations that you can reuse in your projects.

Design Patterns: Values and Limitations
Alright, so let's talk about the values and limitations of the software design patterns. Design patterns are solutions which can be reused in countless projects to solve problems in a safe proven way. You will spend less time on figuring out how to solve a particular issue. You can spend a safe time on implementing the solution and improve the quality of the software product. This way you can provide more value for the money, and your customers will appreciate this. Adopting design patterns have further benefits too. Extending or enhancing a software system that relies on well-established design patterns is easier. Custom solutions are usually not prepared for future changes, and adding new features requires a lot of refactoring work. Besides, refactoring your code base also means that you introduce new bugs. I'm not saying that design patterns eliminates software bugs; however, by using proven strategies, you reduce the risk of implementing solutions that only work in the short-term. Profound frequent changes lead to bugs, and you can lessen the need for such changes by using design patterns. Although design patterns are a great recipe to solve problems that have frequently occurred in software development, they are not without limitations. Whether or not to use a design pattern can be a tough decision. Due to their generic nature, design patterns may not be able to address specific issues. In such cases, you will need to adapt them and change their implementation to fit your particular needs. A certain level of expertise is required to implement design patterns correctly. Unexperienced teams may fail to implement them properly, which can lead to bugs and unexpected delays.

Prerequisites
This is not a Swift beginner course. As an intermediate programming course, prior programming experience may be helpful, but you need not have actually worked with Swift itself. To implement the exercises in this course, you will need the Mac OS X with OS El Capitan. El Capitan is required because Xcode 8 won't install on prior versions of Mac OS. You will also need Xcode 8 with Swift 3. Xcode 8 can be downloaded for free from the Mac App Store. Optionally, download StarUML if you want to check out the UML diagrams or start creating your own diagrams. StarUML 2 is available on staruml. io and can be used for free. You will have to pay $8 in order to get rid of the pop-ups that will show up randomly in the free version.

UML Primer: Overview
Hi there. Welcome to this Unified Modeling Language primer. The Unified Modeling Language, in short UML, is a standard way to communicate the design of a software system. UML is a great tool for object-oriented analysis and design, and it provides a set of diagram types. In this module, I would like to concentrate on those UML artifacts that will be used throughout this course. These are the class diagram, which is static diagram type. It provides a static representation of the classes that form the system. UML relations, classes are interrelated to each other in specific ways. In particular, relationships in class diagrams include different types of logical connections. The sequence diagram is a behavior diagram type, which shows how objects interact with each other. I am going to use StarUML 2 to create the diagrams. StarUML is a popular UML tool, and it runs on Windows, Mac OS, and Linux. You can download it from staruml. io.

Class Diagrams
The class diagram is one of the most frequently used diagram types. It belongs to the Structure diagram category. This diagram type provides an overview of the objects that are forming the system and describes the static relationships between them. Note that class diagrams cannot describe what happens when these relations come to life at runtime. You will need the behavior diagram for the latter. In UML, a rectangle divided into three compartments represents a class. In the top compartment includes the class name in bold. Attributes are written beneath the name compartment. Operations are listed in the bottom compartment. You may want to hide the attributes or the operations compartment, for example, in the early stages of the design phase when details are not yet known. Most UML design tools allow you to do this. Visibility. Class attributes and operations have visibility associated with them. The following symbols are used to describe the visibility. Plus denotes public visibility. Public attributes and operations are accessible by everybody who uses an instance of given class. Hash mark means protected access. Only the current class and derived classes can access protected members. Minus marks private operations and attributes. Only the current class will have access to private members. Use class diagrams to provide an overview of the objects that are forming the software system and to document the static relationships between them.

UML Relations
Hi there. In this clip, I'm going to talk about UML relations. Generalization is a way of describing parent child relations between classes. This relationship is best described by the phrase "B is an A. " For example, a dog is a pet. A cat is also a pet. In UML terms, pet is a base class, whereas dog and cat are derived classes. The UML graphical representation is a hollow triangle on the base class and of the line that connects it to one or more derived classes. An association between two classes represents a connection between instances of those classes. We need association if the instances of two classes need to reference each other in order to function properly. The UML representation is a solid line, which connects the classes. For example, there is an association between an online course and the review. Multiplicity. The end of an association may also include multiplicity, which shows the number of instances participating in the association. An online course either has reviews or not. A review can be written for a specific course, but it may as well be skipped. Possible values for multiplicity. Navigability. Association can be bidirectional where both objects know about each other. However, in some cases, it is unnecessary for both objects to be aware of each other. It makes no sense for the car to know about the driver. In this case, we need a unidirectional association where only one of the objects is aware of the other one. This is a one-way relationship, and it is represented by adding an arrow to the appropriate end of the association. Aggregation. Aggregation is a specific case of association. Aggregation denotes that an object is part of another object. It is also mentioned as a "has-a" relationship. For example, an instructor has a course to present. Aggregation is graphically represented as a hollow diamond shape on the containing class connected with the line with the contained class. Composition. Composition is a stronger variant of the "has-a" relationship, which implies that parts live and die with the whole. For example, the chassis is part of the car. If the car is destroyed, the chassis is destroyed as well. The composition is graphically represented as a filled diamond on the owner end connected with the line with the contained class. Of course, we'll outlive the instructor who created it, whereas the chassis is destroyed together with the car it belongs to. This is why the car chassis is a composition relation, while the instructor course is an aggregation. Realization. Realization shows that the class implements the behavior specified by another model element. Graphically it is represented as a hollow triangle on the interface and connected with dashed lines with the implementers. Dependency. In some cases, a class may depend on another, yet the relation is not an association. This relationship is weak, for instance, if one object sends a notification to another object via a third-party. Another example would be when a class received a reference to another class via a member function argument. A dependency is represented by a dashed line with an arrow at one end. To recap, here are the UML relationships and their graphical representations.

Sequence Diagrams
UML sequence diagrams are one of the most popular UML artifacts for dynamic modeling. They visualize the flow of logic within your system and are commonly used for both analysis and design purposes. Sequence diagrams show the interactions between the objects in a particular scenario of a use case. Lifelines, messages, and executional currencies are the basic visual symbols used to define sequence diagrams. Objects are shown as lifelines running down the page. A lifeline starts with the rectangle containing the object's name, continued by a dotted line, which represents the time the given instance exists during the scenario. Messages. The interaction between the objects is represented by arrows. Each arrow represents a message that descends from one object to another. Messages can be synchronous, which have a solid arrowhead at their end. Return messages are implicit for synchronous messages. Execution occurrence. Seeing the rectangles running down the lifeline denote the duration of an execution called execution occurrence. Asynchronous messages. Asynchronous messages are denoted by a line arrowhead. Asynchronous return messages are shown as a dashed line with the line arrowhead at the other end. Message to self. A self message represents a method calling another method of the same object or a recursive call of an operation. It is shown as a nested focus of control in the lifeline's executional occurrence. Lifeline creation. A lifeline may be created or destroyed during the given scenario. When the lifeline is created as a result of sending a dedicated message from another object's lifeline, the head of the lifeline is shown at the level of the message that creates it. Lifeline termination. If a lifeline is destroyed, it is terminated by a cross symbol. Use sequence diagrams to document the behavior of your system and the interactions between objects in a given scenario, and to validate your logic in a visual manner.

Design Patterns: Classification
Hi there. In this clip, I am going to briefly present the three main software design pattern categories. Design patterns fall into three main categories. Creational patterns are concerned with how objects are created in a software system. The main goal of the creational patterns was to separate the creation of an object from its usage. Consumers are not interested in how objects are created, and exposing such details will lead to unnecessary complexity. Therefore, creational logic should be hidden. Another benefit of creational patterns is the ability to insert dependencies from the outside, also known as dependency injection. This way you can substitute the objects with a different type. The flexibility has many benefits and also allows for better unit testing. Structural patterns define and manage the relationship between objects in an application. The aim of structural design patterns is to provide simple ways to compose objects in order to obtain new functionality. Behavioral patterns describe how objects communicate with one another. In this course, we are going to talk about the creational design patterns. The other two categories will be discussed in our upcoming courses.

Singleton
Overview
Hi, and welcome to another module in the Swift Design Patterns: Creational course. In this module, we are going to take a look at the singleton pattern. After discussing what the singleton is and when you should use it, I am going to show you how to implement it it Swfit 3. 0. We are going to implement a singleton class named SessionState. The SessionState class will act as a center repository for various application settings. Since application settings can be stored and retrieved in parallel by several threads, the SessionState class must be thread-safe to prevent data corruption. I will show you how to ensure the thread safety of our singleton using Grand Central Dispatch. The singleton pattern ensures the uniqueness of an object. You implemented the pattern correctly if only one instance of the given type can be created and that instance cannot be cloned. The singleton instance must be thread-safe since many different components might access it concurrently. You must implement protection against concurrent use for the initialization phase of the singleton and any access to its public properties or methods. To recap, the singleton pattern ensures only one instance of a given type exists, and that instance cannot be copied or cloned. The singleton must be thread-safe since the shared instance can be concurrently accessed by several threads. Okay, so let's implement our SessionState singleton class in Swift 3. 0. First, I am going to show you how to prevent the creation of multiple instances and the cloning of the SessionState object. Next, we will discuss how to protect the singleton against concurrent use.

SessionState: A Naive Approach
This is the UML representation of the SessionState singleton class we are going to implement. The init method is private. The only way to create a SessionState instance is via the shared static property. The SessionState class exposes two public methods, which allow setting and retrieving values based on unique keys, set value forKey and object forKey. Now we know what we'd like to implement, so let's switch to Xcode. I created this free framework project for this demo. It is usually a good idea to create a framework whenever we plan to implement functionality that is likely to be reused by several different apps. The reason I chose a framework over playgrounds is that multi-threading does not work well with playgrounds. We are going to test our singleton instance by calling its methods concurrently; therefore, we cannot rely on playgrounds. Now let's create our SessionState class. First I create a public static property, which is guaranteed to be thread-safe. In Objective-C in prior versions of Swift, we'd use dispatch¬¬_once to protect our shared instance from concurrent access. However, with Swift 3, we do not need this anymore. Static properties and lazily initialized globals are thread-safe by default. Actually, dispatch_once is not available anymore in Swift 3. 0. The next step is to make the init method private, which prevents callers from directly initializing the SessionState class. Our SessionState instance will be used to store and retrieve data based on keys. A private dictionary will be used to store the key value pairs. Let's call it storage. The key must be a string, but the value can be any type. Swift provides two particular types for working with non-specific types. Any can represent an instance of any type at all, including function types. Any object can represent an instance of any class type. Next, I am going to define the methods to access and retrieve the data. The set value forKey method accepts any type as an input parameter and the key of String type. All it does is to add the value based on its key to the internal dictionary. The object forKey method just returns a value for given key. Note that the return value is optional since callers may try to retrieve data that has not been added before. Now we have a singleton implementation with some basic functionality. However, it lacks protection against concurrent access. To illustrate the issue, I am going to implement a unit test. The testConcurrentAccess task method will simulate the concurrent usage of the SessionState singleton instance. Now let me talk a little bit about dispatch queues. A dispatch queue manages the execution of work items. GCD dispatch queues can be either serial or concurrent. Serial queues execute one work item at a time, whereas concurrent queues run all at once, and they can finish in any order. Since we want to simulate a multi-threaded environment, I create an asynchronous DispatchQueue. We must provide the unique label for our asyncQueue. Also, I have to specify that it's a concurrent queue explicitly; otherwise, it will be serial by default. Let's ignore the target parameter and just specify nil for it. The Exodus framework provides a nice way to test asynchronous methods. By defining an expectation object, we can wait until the expectation is fulfilled or until the predefined timeout expires. I am going to call the SessionState set value forKey concurrently from a for loop. The counter should be high enough to reproduce the problem. Let's call the set object forKey method 200 times concurrently. We store the loop counter, and the key is the counter string representation. Next, I am going to read the values that have been stored in our SessionState instance. We read until the biggest counter value is found, that is until all the values are stored. Only then do I call the expect. fulfill method, which will signal that all asynchronous processing is done. The waitForExpectations call won't let the unit test proceed further until the expectation is fulfilled or until the timeout expires. I use a timeout of 10 seconds. Now if we run the test, we observe some weird behavior. Maybe not at first, but after running the test multiple times you should see a crash. If it does not occur, try adjusting the loop counter to higher values. What happened? Well, our singleton is not thread-safe. Internally, the SessionState class uses a dictionary. Neither dictionaries nor arrays are thread-safe. Concurrently accessing a dictionary is a recipe for disaster, which will lead to data corruption crashes. In the next demo, I am going to show you how to protect the SessionState singleton from concurrent access.

Thread-safety with GCD
We just saw what happens if multiple threads call the set value forKey method trying to insert key value pairs in the dictionary at the same time. In this clip, I am going to show you how to address this issue and make the SessionState class thread-safe. If you are using a singleton in a multi-threaded environment, it is very likely that different components will perform simultaneous operations on it. Therefore, protecting the singleton from concurrent access is super important. Alright then, I am going to rely on Ground Central Dispatch and serial queues to synchronize access to the internal storage dictionary. Tasks in serial queues execute one at a time. Each task gets started only after the previous task has finished. When a block of work is submitted to a serial DispatchQueue for synchronous execution, the next work item won't start until the current sync function returns. If two threads are calling the SessionState set value forKey concurrently, the tasks will be serialized and executed one after the other. We use the same technique to protect the getter so that it won't retrieve data from the dictionary while another thread is modifying it. Let's run the unit test again. The test completes successfully, which proves that our singleton is now indeed thread-safe, which is great, but we can improve our code even further. I'll show you how in the next clip.

Generics and Readers: Writer Lock
So far we've implemented the singleton class for storing and retrieving values based on unique keys. We have also addressed the concurrency issues. In this episode, I am going to add some final enhancements to our SessionState class. I am going to refactor the SessionState methods to use generics instead of the type any. With generics, we can specify a placeholder for the type and let the compiler generate the right type based on the arguments passed to the generic function. To define the generic method, we include the placeholder type between two angular brackets after the method's name. The placeholder type can be then used in place of any other type definition. Additionally, I enhance the set value forKey method so that it removes the previously stored value for a given key if a new value argument is passed to the method. Alright, I add a couple of log messages, and the set object forKey method is ready. Next, I am going to refactor the object forKey method too. Let's mark the method as generic. Now I can adjust the return type and the local result variable. Now that both methods are using generics, we can get rid of the casting to int in our unit test code. The next big change is performance related. We saw that it's not safe to concurrently write and read the SessionState's internal dictionary from multiple threads. We solve this issue by using a serial queue to synchronize access to our SessionState singleton, which works, but we can do better. The problem with the serial queue is that each subsequent block of code that is submitted to the queue must wait for the previous one to complete. Allowing multiple threads to retrieve values from the SessionState singleton simultaneously does not present any concurrency hazards as long as no other threads are modifying the internal state of our singleton. The topic of overlapping read and write operations is a classic software development readers-writers problem. If we solve this problem, we could allow concurrent reads, which would speed up execution. Grand Central Dispatch provides a nice and elegant solution. We can create a readers-writers lock using dispatch barriers. This lets us replace our serial synchronization queue with a concurrent one. Dispatch barriers act as serial bottleneck when working with concurrent queues. Using barriers ensures that the submitted block of code is the only work item executed on the given queue. All work items submitted to the queue prior to the dispatch barrier must finish before the block will execute. Subsequent work items won't start until the barrier block completes. The dispatch barrier essentially transforms a concurrent queue to a serial one. Okay, so let's refactor the SessionState class to use dispatch barriers. First, I am going to replace the serial queue with a concurrent one. Then I apply the dispatch barrier in the set object forKey method. To recap, this will temporarily change the behavior of our concurrent queue so that it acts like it was serial. This will ensure that whenever we modify the internal dictionary no other threads can write, do, or read from it. I replace the serial queue in the object forKey method too. Now it uses the newly introduced concurrent queue, which allows executing the read operation in background. Here's our revamped SessionState class. It uses generic methods, which allows us to get rid of all the casting when retrieving values. We've also made performance improvements by implementing a dispatch barrier based readers-writers lock. The later allows retrieving values from the SessionState class concurrently, which speeds up data access.

Summary
Alright, let's summarize what we've learned during this module. The singleton pattern is easy to understand. The aim is to create a class which can have exactly one instance. As easy as it sounds, it requires attention to detail when implementing it. First, we must prohibit the copying or cloning of the singleton instance. We can only use reference types, that is classes, since value types are copied upon assigning them to a new variable. Classes which implement the NSCopying protocol can be cloned; therefore, they cannot be used to create singletons. The singleton instance represents a shared resource that can be used by all components that depend on the given type. These components may access the singleton instance concurrently from different threads. Therefore, the singleton class must be thread-safe. We must protect against concurrent access, its instantiation, and any access to its public members and methods. In the next module, I am going to talk about the prototype design pattern.

Prototype
Overview
Hello, in this module we are going to talk about the prototype pattern. First, I am going to talk about the motivation behind using the prototype pattern. Then I will show you how to implement the prototype pattern in a playground project. The ultimate goal is to come up with a solution to manage AddressBook entries. The prototype pattern should be applied when the construction of new instances is inefficient. If initializing an object is expensive, you should consider using the prototype pattern. The prototype pattern creates clone instances from a prototype object. The clones are created by copying all the properties of the prototype instance. The clones are independent objects. Modifying the clone does not affect the prototype and vice versa. Value types get ultimately copied upon assignment, whereas we need to implement the copying for reference types, that is for classes. The prototype pattern creates new objects by copying a prototype object. Use this pattern if initializing an object is expensive. Okay, so let's implement our prototype samples using Swift Playgrounds. We start with a thread-based implementation, which is a value type in Swift. Value types make implementing the prototype pattern very easy because they are automatically copied upon assignment. Then I'll show you an interesting Swift optimization called copy-on-write. Next, we are going to switch to a class-based approach. Classes are references types in Swift, and unlike value types, they are not automatically copied when assigning their instances to a new variable, so we will have to do some additional coding to implement the prototype pattern. The cloning of objects stands at the core of the prototype pattern. To correctly clone objects, we must understand the difference between the shallow and the deep copy. I am going to provide code examples for that too. Finally, I will show you how to implement the fully- functional AddressBook component which relies on the prototype pattern.

Cloning Value Types
In Swift, value types are copied by default. By using value types, we can implement the prototype without any additional coding. To demonstrate this, I am going to create a struct called Contact. It has two properties of type String, firstName and lastName. Note that strings and all other built-in numeric types, Booleans, enumerations, collections, and tables are implemented as structs. Whenever you assign a building type, its value gets copied and used to create the clone. Okay, so let's create our prototype Contact instance. The contactPrototype variable will point to a Contact instance. Now let's assign the contactPrototype instance to another variable called contactCopy. The values from the prototype instance are copied to the clone. However, their memory addresses will be different. To prove this, I am going to create a helper class for fetching memory addresses off value types. The MemoryUtil exposes a static method called address, which accepts UnsafeRawPointer as an argument and returns the string which contains the formatted memory address. The method uses the unsafeBitCast function to extract the memory address from the provided UnsafeRawPointer argument. As a side note, I am using the unsafeBitCast function solely for demonstration purposes. You should avoid relying on it in production code. We can now fetch the memory address of our value type instances. Let's inspect the address of the prototype and the clone after assignment. Indeed, the memory addresses of the two Contact instances are different. Let's print their content. To get a less cluttered debug information, I am going to provide a custom description for our Contact struct. Our struct must implement the CustomStringConvertible protocol. The CustomStringConvertible protocol declares the description method, which provides a textual representation of a given instance. I'll keep it simple and return the firstName and the lastName as the object's description. Alright, now we can see that the two objects share the same values, but we can improve the testability of our Contact struct further by defining the equality operator. For this, I create an extension which conforms to the Equatable protocol. The Equatable protocol allows implementing the equal to operator. You should add Equatable conformance to your custom types whenever you need more convenient APIs when searching for particular instances in a collection because in that true Contact struct, instances to be equal if the values of their lastName and firstName properties match. When implementing your equality operator you can define any custom logic that makes sense for that particular type. So far value types seem to be a good fit for the prototype pattern. The clone and the prototype do not share the same memory address, and the values of the prototype get copied during assignment. Let's check what happens when we change the values of our clone instance. Since this is a copy, it should not affect the prototype. Because we implemented the equality operator we get not equal for free since two instances are either equal or not. Within the assert, we state that the two instances must not be equal. Also, printing out the description of the prototype and the clone proves that their properties differ. Here is a visual representation of our objects. We have seen that implementing the prototype is an easy task when using value types. In the next clip, I am going to show you an interesting optimization feature applied on certain built-in types.

Copy-on-write Optimization
Copy-on-write is a computing technique that improves performance when copying Swift collection types, that is arrays, sets, and dictionaries. Let's declare an array which holds some integers. When assigning the array to another variable, a copy should be created since arrays are value types. However, checking the addresses of the two array variables does not confirm the expected behavior. Both the original and the copied array point to the same underlying data. Arrays, like all variable size collections in the standard library, use copy-on-write optimization. Multiple copies of an array share the same storage until you modify one of the instances. When that happens, the array being modified replaces its storage with a uniquely owned copy of itself, which is then modified in place. Indeed, if we modified the second array, the memory addresses of the two arrays will be different. Swift takes a full copy at that point so that only the second variable is modified, whereas the first array isn't changed. Copy-on-write is a clever optimization technique which delays the copy operation until it's needed so Swift can insure that no wasted work is done. Note that copy-on-write is a feature specifically added to Swift collections. You don't get it for free for custom data types.

Cloning Reference Types
In this clip, I am going to implement the prototype pattern using a class. Alright, I am going to create a Contact class which has two properties named firstName and lastName. I have to provide the corresponding initializer too. Let's create the prototype instance and assign it to a variable. Unlike value types, reference types are not copied; therefore, the addresses of the two Contact objects will be the same. I have to extend the MemoryUtil class with a new method to display the memory address of reference types. The address generic method can accept any class type argument. Internally, the method relies on the same unsafeBitCast function as its sibling. Now we can inspect the memory addresses of the two Contact instances. Both instances point to the same object as expected. I also create an extension which conforms to the Equatable protocol, which lets us define the equality operator. Now if I update the property values of any of the Contact instances, the change will be deflected by the other one since they are referencing the same object. I am going to implement the CustomStringConvertible protocol so that we can define a convenient description for our Contact objects. To implement the prototype pattern, our Contact class must adopt the NSCopying protocol, which lets you specify how an object should be cloned. The NSCopying protocol declares the copy with zone method, which allows us to create clones of a given object. Our copy implementation creates a new instance and passes the property values of the object to the newly created one. We must explicitly call the copy method during assignment. Since copy returns an object of type any, we must cast the result to the actual type. Now the clone and the prototype point to different objects. Changing one instance does not affect the other. Here is the UML class diagram for our Contact class showing all the protocols it adopted. We have added cloning capabilities to our Contact class by implementing the NSCopying copying with zone method. In the next clip, I am going to talk about shallow and deep copies.

Shallow Copy vs. Deep Copy
In this clip, we are going to talk about shallow and deep copying. These are related to copying objects which contain pointers to other objects. I am going to show you how to copy the real contents instead of just copying pointer values. To illustrate the issue first, let's add the new property of type WorkAddress to our Contact class. To recap, our Contact class already implements the prototype pattern so that we can correctly copy it when needed. So far it only had value type properties, which are ultimately copied correctly. WorkAddress has three properties of type string: streetAddress, city, and zip. Here comes the implementation for the custom description, and we are more or less done with the WorkAddress class. Alright, let's add the WorkAddress property to our Contact class. We must make sure that the new property is initialized in the Contact class init method. I am going to update the copy with zone method too. Next, I initialize the contactPrototype variable. Let's fill out the WorkAddress. Then I assign the copy of the contactPrototype object to a variable called contactCopy. Let's print out the address of the two objects with our MemoryUtil helper class. The addresses of our Contact objects are different, as expected. Next, I am going to change the properties of the contactCopy variable. After printing the description of the two objects, we notice a weird artifact. Although the firtName and the lastName properties are different as they should, the workAddress is the same. The problem is that workAddress is a reference type. When we pass it to the Contact initializer in the copy with zone method, the workAddress object was not copied. Instead, only the pointer, which points to the workAddress property gets copied. This is because as shallow copy was made. Shallow coping means that we copied the address of an object rather than cloning the object itself. Both of the Contact objects will point to the same workAddress object. Printing out the memory address of the workAddress property for both Contact instances confirms this. To solve the problem, we have to insure that the workAddress property contents are copied rather than its memory address. Since firstName and lastName are value types, they are ultimately copied correctly. I am going to implement the deep copying by changing the WorkAddress class so that it adapts the NSCopying protocol. In the Contact class copy with zone method implementation, I have to make sure that the copy of the workAddress property is made by calling the copy method. Indeed, this change fixed the issue. The workAddress property contents and their memory addresses are different. Implementing deep copying for reference types can become a tedious task. Imagine if the firstName and the lastName properties were also reference types. We would have to apply the prototype pattern for each of them. The issue can become very complex if these classes include further class type properties and so on. We'd have to actually copy the entire object graph correctly by adopting the NSCopying protocol in every effected class. Luckily, we get the correct copy behavior if we use value types. In the final clip of this module, we are going to implement the AddressBook demo by exclusively relying on structs so that we don't have to implement the deep copying ourselves.

AddressBook
In this clip, I am going to show you a practical application of the prototype pattern by implementing a simple, yet functional AddressBook example. This is a class diagram of the AddressBook demo. The core component is the AddressBook class, which exposes four public methods for managing contacts. AddressBook is a class because I want it to be shared and mutable. All the other types are value types so that we have the correct copy behavior for free. Based on this blueprint, we can start implementing the demo. First, I am going to create the types the Contact struct depends on. Title is an enumeration which defines some constants. The BasicInfo struct represents the contact's name and title. Next, I implement the Address structure. Note that all stored properties are strings. String is a value type, so we don't have to implement the deep copying. Then we are going to define the Employment struct. The workAddress property is of type Address. Address is a struct, which means that again we get the correct deep copy behavior for free. To recap, by using structs and enums, we made our code simpler since we don't have to implement the copy logic. Now we can implement the Contact struct since all the custom types to required to define its stored properties are available. Only the BasicInfo is mandatory. All the other stored properties are optional. The AddressBook class has an internal array of contacts. This array is not public since we do not want callers to directly modify it. Instead, I am going to expose a couple of public methods to retrieve and modify the contacts. Restricting direct access to some of the object's components is one of the fundamental object-oriented programming paradigms. Hiding data is safer since we keep things under our control. Besides, this allows us to change the implementation for managing the contacts without the need to refactor the caller's code. I expose a read-only public contacts variable, which returns the stored contacts. The add contact method records a new contact. I check whether the given contact has already been added using the array's index of method. Now we have an arrow telling us that index cannot be invoked with an argument of type Contact. This happens because index has no way of telling whether two contact instances are equal due to the lack of the equality operator, so let's implement the equality operator for the Contact struct. Alright, when adding a new contact, the list of contacts gets sorted by name. When retrieving the contacts, the AddressBook class will return a nicely sorted list of contacts. The remove contact method allows removing a previously stored contact. We should also have search capabilities. I am going to rely on the array filter function and return contacts which contain the supplied search term in their fullname property. Now let's try out our implementation. I create the AddressBook instance. Next, I instantiate the BasicInfo object and an Employment instance. These objects are then used to construct the contactPrototype variable. Our Contact object is apparently missing a custom description, so let's add one. Except for the BasicInfo property, all other properties are optional. I am going to use optional binding to find out whether there is a value inside the optional property and extract that value into constant. I prefer this technique because it's less variables than checking for nil and forced unwrapping optionals. We have to implement the custom description for all the custom types used by the Contact struct. BasicInfo description returns the title and the fullname. Title is a enumeration of strings, so I simply return the rawValues. The description for address is built from its stored properties of type String. Again, I use optional binding to check whether the option of phoneNumber has a value. If it has, then I append the value to the address description. Finally, I am going to implement the description for our Employment struct. We are done with the custom descriptions. Now we get to clean, unclutter description for our contact instances. Okay, now let's assign the contactPrototype to a couple of new variables. To validate our prototype implementation, I am going to update the workAddress for Mary Mitchell. This change must not affect the other contact objects. Great, it works as expected. The workAddress change for Mary Mitchell was not propagated to the other contacts. Now we are going to add these contact objects to the AddressBook. To see the results, I am going to add a custom description to the AddressBook class. We iterate through the contacts and concatenate the contact descriptions. Now if we print out the description of the AddressBook instance, the console will be populated with all the contacts and their details. Next, we try out the search capability of the AddressBook class. This works nicely too. Last but not least, let's try the remove method. Everything works as expected. We have a simple yet functional AddressBook. Note that performing such quick functional tests is not sufficient in a real world application or framework. Normally we'd have to create unit tests to accurately test our implementation. Alright, this was our AddressBook demo. In the next closing clip, I am going to summarize what we've learned about the prototype pattern.

Summary
Let's try to summarize what we've learned during this module. The prototype should be used when creating new instances if a given type is inefficient. Instead of constructing new objects, the prototype pattern creates new instances by cloning a prototype object and copying all its properties. The copied instance is an independent object. Changing its properties doesn't affect the cloned object. In Swift, value types are automatically cloned; therefore, you get the behavior required to implement the prototype pattern for free. Classes are reference types, which are not automatically copied during assignment or when passing them to functions or methods. To implement the prototype pattern, classes must adopt the NSCopying protocol. You need to understand the difference between a shallow copy and a deep copy. A deep copy duplicates the object's reference, while a shallow copy duplicates only the references, that is the pointers to those objects. You need to consider the entire object hierarchy that you are cloning and not just the top one on which you call the copy method. You must carefully decide for each reference type property whether a shallow copy is enough or we rather need a deep copy.

Builder
Motivation
Hi there, and welcome to this module on the builder pattern. First, I talk about what the builder pattern is and the motivation behind using it. Then we are going to look at how to implement the builder pattern. The final goal is to create a ThemeBuilder class, which lets us easily configure and instantiate themes which define the colors and fonts used in an application. The builder pattern helps when we need to create complex objects which require many configuration values. The builder pattern is a good choice when the objects to be created can usually use some predefined defaults, and you rarely need to modify these values. The point is that callers can customize the default configuration values, but usually most of these defaults remain unchanged. This pattern encapsulates the default configuration values and the required set-up logic required to create an object into a builder class. The builder pattern separates the configuration of an object from its creation. It simplifies the creation of instances which need many default values, and those values usually don't change frequently when creating new objects. Okay, so let's implement our ThemeBuilder demo in Swift 3. 0.

The Telescoping Initializers Anti-pattern
In this example, I am going to create a Theme class which holds a couple of basic UI related properties: backgroundColor, textColor, and font. We will need more properties for a real-life application, but let's keep it simple for this demo. We need to define a public initializer for our class. The init method arguments match the properties of the Theme class. Now that our Theme class is ready, let's try it out. I am going to initialize the Theme instance with the white backgroundColor, black textColor, and the systemFont. Next, I create a UILabel instance and provide its frame. We use the previously created theme to set the corresponding properties of the label. Let's assume that we need another label, but the textColor should be red. So I create a new Theme object which has the same backgroundColor and font as the previous theme, but the textColor is different. Next, we apply the theme properties to our second label. Most of our labels will usually have a white background and use the same font. However, the textColor might change, for example, to display an alert or highlight an important message. Let's try to simplify the creation of the Theme instance by implementing convenience initializers that provide default values. We must keep the default init, which has all the arguments. I am going to add another init method, which does not include the font argument. It uses a default systemFont ofSize 15. Next, I am going to narrow the initializer argument list further by omitting the textColor. Let's use black color as default textColor. Finally, a convenience initializer with no arguments at all. It uses a default white backgroundColor and calls the convenience initializer with a single argument. The convenience initializer with a narrower argument list calls the proceeding initializer with the default value. Now we can instantiate our theme objects by providing all arguments, only some of them, or none at all. For example, if we are fine with having default backgroundColor, textColor, and font, we can instantiate our Theme instance like this. And if we are fine with the default font, yet we need custom background and text colors, we'd proceed like this. Although this approach seems to do the job, we should avoid it. The so-called telescoping initializer is an anti-pattern. Telescoping initializers may result in a large number of initializers which are hard to maintain. Swift offers a better approach by using the full parameter values. Okay, let's clean up our Theme class by using a single initializer with default values. Our class became a lot cleaner, isn't it? And we can use it just as before, yet with a way cleaner class implementation. We managed to avoid the telescoping initializer anti-pattern by using Swift default parameter values. In the next clip, I am going to show you how to separate the creation of theme objects from their configuration.

The ThemeBuilder
In this clip, we are going to implement the ThemeBuilder class, which will take over the responsibility of configuring theme objects. First, let's take a look at the Cocoa Touch example of the builder pattern. The DateComponents class is actually a builder, which allows configuring custom properties and gives us a date object constructed using the values we provide. The DateComponents class uses default values for the properties we do not set. We can configure a date by specifying only the properties we are interested in. For everything else, it applies built-in defaults. If we set the timeZone, we are going to get different results from GMT and say PST since the difference is 8 hours. Alright, let's implement our ThemeBuilder class following a similar approach. When designing your API, it's always a good idea to follow the already available and active solutions offered by Apple. Your API should be similar to what developers encounter in the official SDK. Okay, let's check out the UML class diagram of our ThemeBuilder class. The ThemeBuilder exposes the same properties as the Theme class. I move the Theme defaults to the ThemeBuilder class. Configuring the Theme becomes the responsibility of the ThemeBuilder. The public Theme property returns a configured theme instance, which makes it unnecessary to instantiate it directly. The ThemeBuilder follows the same approach as the DateComponents class. It allows setting the values we need to customize while providing the faults for the rest. The ThemeBuilder creates the Theme objects when the caller reads the Theme property. The caller must provide all custom configuration values before retrieving the theme object. Let's see how the ThemeBuilder works. First, I am going to instantiate a ThemeBuilder instance. It's Theme property returns a theme instance with default values. Let's apply these defaults to a UILabel. Indeed we have a white background, black text, and the system font. Next, I am going to change the backgroundColor to yellow by changing the ThemeBuilder instance backgroundColor property. When their reading the Theme property, a new theme instance is created, which has a yellow backgroundColor, but has defaults applied for all the other properties. Let's prove this by applying the theme to a label. We can play with any other property, like the textColor or the font. The following UML sequence diagram summarizes the steps used to configure and build a theme using the ThemeBuilder.

Summary
Let's try to summarize what we've learned during this module. The builder design pattern is the best fit for situations when an instance implies complex configuration steps and you don't need to change the settings frequently when creating new objects. The builder pattern separates the configuration of objects from their creation. The builder class contains all the logic and the default configuration values required to build an object. Callers must only provide minimal configuration values, and they must not know all the defaults that are needed to build an object.

Factory Method
Overview
Hello, in this module, we are going to talk about the factory method pattern. First, I am going to talk about the motivation behind using the factory method pattern. Then we are going to implement the ColorThemePicker component, which allows choosing a color palette using the factory method design pattern. The factory method pattern allows callers to create instances of objects by only knowing the protocol or the top level base class and not the exact implementation classes. This way callers must not know any details about the implementation classes. The factory method incorporates the logic required to decide which implementation class to instantiate based on the criteria supplied by the caller. Callers must not know all the implementation classes, just the protocol or the base class. In the demo that follows, we are going to implement the way to create color palettes using the factory method design pattern.

Factory Method
To illustrate the problem that is solved by the factory method pattern, I am going to create a protocol and a couple of conforming classes. We'll start by setting up the ColorPalette protocol. It exposes two read-only properties, BackgroundColor and TextColor, which are both of type UIColor. The conforming classes will return different background and textColor values when callers read their corresponding properties. Finally, we are going to apply these palettes on the UILabel instance. Alright, let's switch to Xcode. For this example, I am using a Swift Playground. I am going to implement the ColorPalette protocol first. Both properties are read-only; hence, we expose only getters. Next, we will implement the WhiteboardPalette struct, which conforms to the ColorPalette protocol. It returns white for the backgroundColor and black for the textColor, whereas the BlackboardPalette returns a black background and white textColor. Now let's create a UILabel instance. First, I am going to apply the whiteboardPalette colors to our label. We've got the expected results. Then we create the BlackboardPalette instance. Let's use its colors to change the label's background and textColor. Our inverted palette also produces the expected result. How about creating a third palette? The MilkCoffeePalette defines a brown backgroundColor and the white textColor. Again, to apply it, we have to create an instance of the MilkCoffeePalette class. So far we've been using only predefined color values. UIColor offers various initializers to create custom colors, but let's come up with something special. I am going to implement a way to create colors from HTML color code values. The HTML color code is the hexadecimal representation of the add GB byte values. I define the new method in the UIColor extension. Extensions are a smart way to add functionality to existing classes. To extract the color components, I use masking and bitwise shifting. Finally, I use one of the official UIColor initializers. Great, now we can create colors from HTML color codes. The NightSwimmingPalette will rely on the custom UIColor initializer to create a nice dark blue background color. We can use the new palette right away. Now we have four palettes, and we used each of them to decorate the UILabel instance. While this works, it's far from being perfect. The main issue here is that we must know each implementation class in order to instantiate it directly. If any of these classes changes, or whenever a new color palette class gets created, the caller code must be adapted. Refactoring a complex code base can be time-consuming and expensive. Besides, there is no real benefit to having the color palette protocol at all. Wouldn't it be better if the caller component only knew the protocol and not the implementation classes themselves? In the next module, I am going to show you how to achieve this using the factory method design pattern.

Embedding the Factory Method in the Base Class
Alright, so let's implement the factory method pattern. Our aim is to hide the concrete implementation classes from the callers and only expose the common protocol. To implement the pattern, I am going to expose a global function. The function must define the parameters needed to select the implementation class to instantiate. The argument, in our case, will be of type enumeration. I define the ColorTheme enumeration values so that their names match the implementation classes. The makePalette global function accepts a single argument of type ColorTheme. The return value is of type ColorPalette, which is the protocol implemented by all our palette classes. Implementing the factory method is quite straightforward. Based on the argument supplied by the caller, the method will instantiate the appropriate class. Now we can replace all the occurrences of initializing the specific classes with calls to our recently introduced factory method. Next, I am going to get rid of the call to the BlackboardPalette initializer. Then comes the MilkCoffeePalette, and finally, the NightSwimmingPalette. There are no references left to any of the implementation classes. Let's create a new ColorPalette implementation. To create the PinkyPalette object using the factory function, I have to add the new enumeration value. Then I am going to enhance the makePalette function. The consumer side is entirely unaware of the new implementation class. The caller must only know about the new enumeration value to create the PinkyPalette object. Global functions are just one way to implement the factory method pattern. If you don't like global functions, you can embed the factory method in a class. The PaletteFactory class acts as a namespace for our factory method. The implementation for the makePalette method is the same as before. The only change is that now we have a type method rather than a global function. Note that the class keyword allows subclasses to override the type method. Use static to restrict subclasses from overriding the makePalette method. It is convenient that we can invoke the makePalette method on the type itself without having to create an instance of the given class. Let's replace the global function calls for the WhiteboardPalette. Next comes the BlackboardPalette, then the MilkCoffeePalette, and finally, the last two, the NightSwimmingPalette and the PinkyPalette. Alternatively, we could replace the ColorPalette protocol with the base class. I am going to include the factory method implementation in the base class itself. Encapsulating the factory method in the ColorPalette base class gives us a robust self-contained solution. I am going to define the backgroundColor and the textColor computed properties as final so that subclasses cannot override them. The base class exposes an initializer which has two arguments. Next, I am going to implement the factory method. Its signature should look familiar, except that now we return the base class type. Let's create the palette subclasses. Note that we must use classes because subclassing is not possible with structures. The initializer is fileprivate, which prevents callers from creating instances of the ColorPalette subclasses. The initializer calls the base class init method and provides the values for the background and the textColor. We are going to follow the same pattern for all the other subclasses. Now we can create ColorPalette objects by calling the base class make method. We have seen three different ways to implement the factory method design pattern, via global functions, by including the factory logic in a dedicated factory class, and by encapsulating the factory method in the base class itself. All this variance ensured that the implementation classes remain hidden and callers must only know the protocol or the base class and the factory method. By hiding the details, changes in the implementation classes won't have ripple effects on the caller's side. The factory method is one of the most straightforward and most frequently used creational design patterns.

Summary
Let's recap what we've learned during this module. The factory method pattern is a good choice if we want to prevent exposing all implementation classes to our callers. Depending components must only know about the protocol or the base class and the class exposing the factory method. This pattern allows changing the existing implementation classes or adding new ones without exposing these details to the components that rely on them. Note that the factory method design pattern cannot be applied when there is no common protocol or shared base class.

Abstract Factory
Overview
Hello. In this module, we are going to talk about the abstract factory. This pattern is similar to the factory method pattern, except that it returns a set of related objects instead of just one. First, I am going to talk about the motivation behind using the abstract factory pattern. Then we are going to implement the ComputerShop demo app to demonstrate the real-life application of this pattern. The motivation behind using the abstract factory design pattern is to create objects which belong to a group, but inherit from several different base classes or implement different protocols. The actual classes which are used to create the objects remained hidden, which lets us modify the factory without having to refactor the caller's code. The abstract factory design pattern is similar to the factory method pattern, but the caller does not know which classes were involved in the creation process. The approach makes it possible to change the factory classes without modifying the callers. The abstract factory design pattern should be applied when you need to create a set of related objects. To create single objects, choose the factory method pattern instead. I am going to showcase the abstract factory pattern by implementing a demo which lets us create different computer configurations.

Motivation
To understand the problem solved by the abstract factory design pattern, we are going to implement a ComputerStore demo. Here are the protocols and the implementation classes for the parts that can be used to configure a computer. Clients can choose between a white or a black computer case finish, solid state drive or conventional hard disk, four processor types, and three memory configurations. Let's switch to Xcode. I created the Playground project for this demo. First, let's define the Finish protocol. It adopts the CustomStringConvertible protocol to provide a custom description. The Finish protocol defines two properties, the color and the price. Next, I am going to create the WhiteFinish and the BlackFinish implementation classes. The BlackFinish has a higher price than the white one. Now I am going to define the Storage protocol. It depends on two custom enumeration types, which represent the StorageType and the capacity. Clients can choose between a flash drive or a hard disk drive. Storage capacities are 512GB, 1TB, and 2TB. Let's implement the Storage implementation classes. I set the price based on the StorageType and size. Float storage is the most expensive, and the bigger the capacity, the higher the price. The Processor protocol declares the processor type and speed. I introduced enumerations to define the possible values for these types. The BasicProcessor implementation class is the cheapest option. You get a dual core 1. 4GHz entry level CPU in this case. The most expensive CPU has 4 cores and a transit of 3. 2GHz. Finally, I am going to implement the Memory protocol and three implementation classes so clients can select between basic, advanced, and professional memory options. We have now various parts to choose from so that we can put together different computer configurations. I define the Computer structure, which has the following properties: Finish, Storage, Processor, Memory, and Price. The Price is a computed property, which sums up the price of the selected parts. Alright, let's create some computer instances. I start with the cheapest configuration. This machine comes with a SmallHardDisk, the least performing dual core processor, and the BasicMemory configuration. Then I create a more powerful computer instance called officeComputer. And finally, the highEndComputer, which is put together using the best available parts. The results and all the details are printed in the console. Now the issue with the current approach is that we expose all our individual implementation classes to the callers. The situation is quite similar to what we saw back then using the factory method design pattern, except that now we have to handle a set of related object types instead of just one type. In the next clip, I am going to show you how to apply the abstract factory pattern to get rid of these unwanted dependencies.

Abstract Factory
Alright, so let's see how the abstract factory pattern helps us in getting rid of the direct dependencies to our implementation classes. I am going to create an enumeration which reflects the computer configurations that we provide. Next, let's implement the class name ComputerFactory. This class will act as the base class for our concrete factory classes. The ComputerFactory class defines the factory methods that return the required parts to build a computer. Note that the method to return nil when invoked on the ComputerFactory instance. Only subclasses should return valid values as a reminder to callers not to use the base class directly. The type method makeFactory stands at the call of the abstract factory pattern. This method returns the chart of the Factory base class. The method is final to prevent overriding it by subclasses. The makeFactory method instantiates one of the ComputerFactory subclasses based on the ComputerType arguments supplied by the caller. I am going to implement the BasicComputerFactory subclass. The makeFinish, makeStorage, makeProcessor, and makeMemory methods return the configuration needed for the basic computer setup. In a similar fashion, we implement the OfficeComputerFactory, DeveloperComputerFactory, and HighEndComputerFactory. These subclasses will return different computer configurations. Now we have all ComputerFactory subclasses, so I can complete the makeFactory class method. The next step is to try out our new abstract factory. For this, we have to instantiate the right factory. Notice that the caller's side can only interact with the ComputerFactory class. I mark the concrete subclasses as file private so they are not visible outside their source file. So let's create the basicComputerFactory. I pass in the value basic for the type argument. The makeFactory method will return the basicComputerFactory instance, but the caller is not aware of this fact. Only the base class is visible, which was our initial goal. I am relying on optional binding to retrieve the values using the factory method safely. Next, I am going to create a computer object using the values returned by the basicComputerFactory. Printing the computer instance to the console confirms that the factory provided the basic configuration values as expected. Let's create the developer and the highEndComputer configuration too. We will need the respective factories for that. Again, I am relying on the makeFactory class method, and by supplying the right type value, I get the expected factory object. After creating the computer instances, let's take a closer look at the debug information. The values and the price reflect the various configuration types. Here's a detailed UML class diagram, which shows what we achieve by applying the abstract factory design pattern. The caller, in our case the computer structure, has no knowledge about the BasicComputerFactory, neither about the concrete storage, processor, or memory implementation classes. Caller components interact with the ComputerFactory base class, and the Finish, Storage, Processor, and Memory protocols. The abstract factory should be used to create groups of related objects and isolate consumers from the classes that are used to create the objects. Choose the factory method if the objects you want to create share a single protocol or base class.

Summary
Let's recap what we've learned during this module. The abstract factory pattern should be used if we want to create a set of objects which are part of a group, but do not implement the same protocol or base class. By hiding the concrete factories that are used to create the objects, this pattern allows us to modify the factories without affecting the caller. The abstract factory defines a method that will return an implementation of a factory protocol or a factory base class. The concrete implementation class is selected, which is a class that implements the factory method design pattern. Finally, the factory method is invoked, and the required instance is created.
